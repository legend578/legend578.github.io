<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大量数据批量存入的性能优化</title>
      <link href="/2025/04/29/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2025/04/29/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>当在数据量比较大需要插入时，进行逐条插入MySQL可能会速度很慢，所以这时有几种思路来进行优化</p><h2 id="1-使用mybatisPlus的saveBatch方法进行批量插入"><a href="#1-使用mybatisPlus的saveBatch方法进行批量插入" class="headerlink" title="1.使用mybatisPlus的saveBatch方法进行批量插入"></a>1.使用mybatisPlus的saveBatch方法进行批量插入</h2><p><strong>service调用</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookMapper, Book&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concurrentBatchInsert</span><span class="params">(List&lt;Book&gt; books, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据分片，需要引入hutool依赖，给books中的100w数据进行分片，每个list子集合1000条数据</span></span><br><span class="line">        List&lt;List&lt;Book&gt;&gt; batches = ListUtil.partition(books, batchSize);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Book&gt; batch : batches) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始批量插入数据&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.saveBatch(batch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;耗费时间：&quot;</span>+String.valueOf(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：34723ms</span><br></pre></td></tr></table></figure><h2 id="2-使用foreach进行sql拼接，来进行批量插入"><a href="#2-使用foreach进行sql拼接，来进行批量插入" class="headerlink" title="2.使用foreach进行sql拼接，来进行批量插入"></a>2.使用foreach进行sql拼接，来进行批量插入</h2><p><strong>service调用逻辑</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookMapper, Book&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concurrentBatchInsert</span><span class="params">(List&lt;Book&gt; books, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据分片，需要引入hutool依赖，给books中的10w数据进行分片，每个list子集合1000条数据</span></span><br><span class="line">        List&lt;List&lt;Book&gt;&gt; batches = ListUtil.partition(books, batchSize);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Book&gt; batch : batches) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始批量插入数据&quot;</span>);</span><br><span class="line">            bookMapper.insertBatchSomeColumn(batch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;耗费时间：&quot;</span>+String.valueOf(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapper接口层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Book&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertBatchSomeColumn</span><span class="params">(<span class="meta">@Param(&quot;batch&quot;)</span> List&lt;Book&gt; batch)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapper.xml</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.sky.work_test.mapper.BookMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">&quot;insertBatchSomeColumn&quot;</span>&gt;</span><br><span class="line">        INSERT INTO <span class="title function_">book</span> <span class="params">(bkname,sid,price,author,sur)</span></span><br><span class="line">        VALUES</span><br><span class="line">        &lt;foreach collection=<span class="string">&quot;batch&quot;</span> item=<span class="string">&quot;item&quot;</span> separator=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">            (#&#123;item.bkname&#125;, #&#123;item.sid&#125;,#&#123;item.price&#125;,#&#123;item.author&#125;,#&#123;item.sur&#125;)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：29760ms</span><br></pre></td></tr></table></figure><h2 id="3-在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务"><a href="#3-在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务" class="headerlink" title="3.在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务"></a>3.在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务</h2><p><strong>此处使用线程池异步并发来处理批量任务插入，插入方法可以是sql拼接或者mybatisPlus的saveBatch</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookMapper, Book&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor  dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span><span class="comment">//异步执行</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concurrentBatchInsert</span><span class="params">(List&lt;Book&gt; books, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">        <span class="comment">//创建list集合接受线程的返回值</span></span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据分片，需要引入hutool依赖，给books中的100w数据进行分片，每个list子集合存放1000条数据</span></span><br><span class="line">        List&lt;List&lt;Book&gt;&gt; batches = ListUtil.partition(books, batchSize);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Book&gt; batch : batches) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始批量插入数据&quot;</span>);</span><br><span class="line">            <span class="comment">//开启多个线程并行执行</span></span><br><span class="line">            CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                bookMapper.insertBatchSomeColumn(batch);</span><br><span class="line">            &#125;, dataProcessingExecutor);</span><br><span class="line"></span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有数据插入完成后退出阻塞</span></span><br><span class="line">        CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(String.valueOf(endTime-startTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用foreach的sql拼接插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：7024ms</span><br></pre></td></tr></table></figure><p><strong>使用mybatisPlus的saveBatch方法进行插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：7565ms</span><br></pre></td></tr></table></figure><h2 id="测试插入"><a href="#测试插入" class="headerlink" title="测试插入"></a>测试插入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookServiceImpl bookService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/insert&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertLargeData</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//主键设置为自增</span></span><br><span class="line">            <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">            book.setSid(<span class="string">&quot;s99&quot;</span>);</span><br><span class="line">            book.setBkname(<span class="string">&quot;sky&quot;</span>);</span><br><span class="line">            book.setPrice(<span class="number">99</span>);</span><br><span class="line">            book.setAuthor(<span class="string">&quot;sky&quot;</span>);</span><br><span class="line">            book.setSur(<span class="number">99</span>);</span><br><span class="line">            data.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">        bookService.concurrentBatchInsert(data,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大量数据插入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池的异步并发操作以及CompletableFuture的使用</title>
      <link href="/2025/04/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/04/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么定义线程池"><a href="#怎么定义线程池" class="headerlink" title="怎么定义线程池"></a>怎么定义线程池</h2><h3 id="定义配置类来接收线程池参数"><a href="#定义配置类来接收线程池参数" class="headerlink" title="定义配置类来接收线程池参数"></a>定义配置类来接收线程池参数</h3><p>可以在application.yml中配置线程池相关的参数，将该配置封装为一个类，作为bean注入到spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerAppConf</span> &#123;</span><br><span class="line">     <span class="meta">@Value(&quot;$&#123;scheduler.pool.corePoolSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> corePoolSize;<span class="comment">//核心线程数一般根据任务类型配置</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;scheduler.pool.maxPoolSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxPoolSize;<span class="comment">//一般定义为100</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;scheduler.pool.queueCapacity&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueCapacity;<span class="comment">//一般定义为9999</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;scheduler.pool.namePrefix&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String namePrefix;<span class="comment">//线程池中线程的名字前缀</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例化线程池作为bean注入到spring容器"><a href="#实例化线程池作为bean注入到spring容器" class="headerlink" title="实例化线程池作为bean注入到spring容器"></a>实例化线程池作为bean注入到spring容器</h3><p>将线程池配置类注入，使用ThreadPoolTaskExecutor构建线程池，进行一系列的参数设置，将构建出的线程池注入到spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span><span class="comment">//运行方法异步执行</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SchedulerAppConf schedulerAppConf;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;schedulerPool&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">schedulerPoolExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//将该方法的返回值ThreadPoolTaskExecutor作为bean注入到spring容器中</span></span><br><span class="line">        log.info(<span class="string">&quot;start schedulerPoolExecutor&quot;</span>);</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">//配置核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(schedulerAppConf.getCorePoolSize());</span><br><span class="line">        <span class="comment">//配置最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(schedulerAppConf.getMaxPoolSize());</span><br><span class="line">        <span class="comment">//配置队列大小</span></span><br><span class="line">        executor.setQueueCapacity(schedulerAppConf.getQueueCapacity());</span><br><span class="line">        <span class="comment">//配置线程池中的线程的名称前缀</span></span><br><span class="line">        executor.setThreadNamePrefix(schedulerAppConf.getNamePrefix());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rejection-policy：当pool已经达到max size的时候，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">//执行初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="怎么开启线程池的异步处理功能"><a href="#怎么开启线程池的异步处理功能" class="headerlink" title="怎么开启线程池的异步处理功能"></a>怎么开启线程池的异步处理功能</h2><p>1.在application启动类上添加@EnableAsync注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;cn.bitoffer&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XTimerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(XTimerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在实例化线程池时添加@EnableAsync注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span><span class="comment">//运行方法异步执行</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncPool</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.对需要异步处理的方法添加@Async(“schedulerPool”)注解，表示当前方法会放入线程池中异步处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async(&quot;schedulerPool&quot;)</span></span><br><span class="line"><span class="comment">//@Async(&quot;schedulerPool&quot;)：这个注解表示 asyncHandleSlice 方法会在一个新的线程中异步执行。</span></span><br><span class="line"><span class="comment">//Spring会将这个方法提交给名为 schedulerPool 的线程池，线程池的配置是在 AsyncPool 类中定义的（通过 ThreadPoolTaskExecutor）。</span></span><br><span class="line"><span class="comment">//异步执行意味着该方法的调用不会阻塞当前线程，调用者可以继续执行其他操作。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncHandleSlice</span><span class="params">(Date date,<span class="type">int</span> bucketId)</span> &#123;</span><br><span class="line">    ...方法逻辑</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="怎么开启线程池并发处理任务的功能"><a href="#怎么开启线程池并发处理任务的功能" class="headerlink" title="怎么开启线程池并发处理任务的功能"></a>怎么开启线程池并发处理任务的功能</h2><p>想要使用线程池的并发处理任务功能，可以使用CompletableFuture提供的方法来方便地进行并发处理任务</p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>本文的CompletableFuture内容参考<a href="https://blog.csdn.net/javaeEEse/article/details/136186918">CompletableFuture使用详解（超详细）-CSDN博客</a></p><p><strong>CompletableFuture</strong>就是帮你处理这些任务之间的逻辑关系，编排好任务的执行方式后，任务会按照规划好的方式一步一步执行，不需要让业务线程去频繁的等待</p><p><strong>函数式编程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;U&gt;  <span class="comment">// 生产者，没有入参，有返回结果</span></span><br><span class="line">Consumer&lt;T&gt;  <span class="comment">// 消费者，有入参，但是没有返回结果</span></span><br><span class="line">Function&lt;T,U&gt;<span class="comment">// 函数，有入参，又有返回结果</span></span><br></pre></td></tr></table></figure><p><strong>先创建一个辅助类方便结果输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">smallTool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleepMillis</span><span class="params">(<span class="type">long</span> millis)</span>&#123;<span class="comment">//该方法主要是模拟线程的休眠</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(millis);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printTimeAndThread</span><span class="params">(String tag)</span>&#123;<span class="comment">//该方法主要是通过接受参数，再将调用该方法的该线程信息输出</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;\t|\t&quot;</span>)</span><br><span class="line">                .add(String.valueOf(System.currentTimeMillis()))</span><br><span class="line">                .add(String.valueOf(Thread.currentThread().getId()))</span><br><span class="line">                .add(Thread.currentThread().getName())</span><br><span class="line">                .add(tag)</span><br><span class="line">                .toString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="supplyAsync（无参，有返回值）"><a href="#supplyAsync（无参，有返回值）" class="headerlink" title="supplyAsync（无参，有返回值）"></a>supplyAsync（无参，有返回值）</h4><p>CompletableFuture中的supplyAsync方法，会开启一个新的线程，和主线程异步同时的执行任务；需要提供返回值，不提供参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白进入餐厅&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白点了菜+饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师打饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;菜和饭做好啦！&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor);<span class="comment">//指定使用的线程池</span></span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在刷视频&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s小白开吃&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><p>小白刷视频和厨师炒菜是同时开始进行的，先后顺序看情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745915054515|1|main|小白进入餐厅</span><br><span class="line">1745915054517|1|main|小白点了菜+饭</span><br><span class="line">1745915054521|1|main|小白在刷视频</span><br><span class="line">1745915054521|25|DataProcessor-1|厨师炒菜</span><br><span class="line">1745915054732|25|DataProcessor-1|厨师打饭</span><br><span class="line">1745915054841|1|main|菜和饭做好啦！小白开吃</span><br></pre></td></tr></table></figure><p>结果说明：开始的执行时间+线程id+线程名称+消息</p><h4 id="runAsync（无参，无返回值）"><a href="#runAsync（无参，无返回值）" class="headerlink" title="runAsync（无参，无返回值）"></a>runAsync（无参，无返回值）</h4><p>runAsync和supplyAsync使用方法相同，唯一的区别就是runAsync没有返回值，执行完代码逻辑后会直接退出</p><h4 id="thenApply（拼接代码）"><a href="#thenApply（拼接代码）" class="headerlink" title="thenApply（拼接代码）"></a>thenApply（拼接代码）</h4><p>thenApply()：把前面任务的执行结果，交给后面的Function，共用同一个线程，可以对前面的返回结果进行一系列处理后再返回</p><p>thenApply相当于把两块代码拼接到了一起，thenApply前面的代码和后面的代码是一起执行的，thenApply只作为拼接的作用，封装两段代码作为一个任务给一个线程去执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白吃完饭&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白准备结账&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1进行结账&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;500元&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenApply(money -&gt;&#123;<span class="comment">//这里共用同一个线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1开小票&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s&quot;</span>,money);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在打电话&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;小白付款%s&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745929093000|1|main|小白吃完饭</span><br><span class="line">1745929093000|1|main|小白准备结账</span><br><span class="line">1745929093002|25|DataProcessor-1|服务员1进行结账</span><br><span class="line">1745929093002|1|main|小白在打电话</span><br><span class="line">1745929093204|25|DataProcessor-1|服务员1开小票</span><br><span class="line">1745929093312|1|main|小白付款500元</span><br></pre></td></tr></table></figure><h4 id="thenApplyAsync"><a href="#thenApplyAsync" class="headerlink" title="thenApplyAsync"></a>thenApplyAsync</h4><p>该方法表示thenApplyAsync前面的代码块和后面的代码块是独立的两个异步任务，并不会像thenApply一样直接拼接，而是会开辟一个新线程来执行独立的任务或者复用原来的线程（虽然复用原来的线程是一个线程，但是异步任务是两个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白吃完饭&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白准备结账&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1进行结账&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;500元&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenApplyAsync(money -&gt;&#123;<span class="comment">//这里共用同一个线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1开小票&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s&quot;</span>,money);</span><br><span class="line">        &#125;,dataProcessingExecutor);</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在打电话&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;小白付款%s&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745928885934|1|main|小白吃完饭</span><br><span class="line">1745928885934|1|main|小白准备结账</span><br><span class="line">1745928885937|25|DataProcessor-1|服务员1进行结账</span><br><span class="line">1745928885937|1|main|小白在打电话</span><br><span class="line">1745928886145|26|DataProcessor-2|服务员1开小票</span><br><span class="line">1745928886255|1|main|小白付款500元</span><br></pre></td></tr></table></figure><h4 id="thenCompose（线程顺序执行）依赖"><a href="#thenCompose（线程顺序执行）依赖" class="headerlink" title="thenCompose（线程顺序执行）依赖"></a>thenCompose（线程顺序执行）依赖</h4><p>thenCompose()：当不同线程的任务执行有先后顺序时，并且依赖其返回值，则使用thenCompose；用来连接两个有依赖关系的任务，结果由第二个任务返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白进入餐厅&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白点了菜+饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;<span class="comment">//新开启一个厨师线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;番茄炒蛋&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenCompose(dish-&gt;CompletableFuture.supplyAsync(()-&gt;&#123;<span class="comment">//新开启一个服务员线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员打饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> dish+<span class="string">&quot;饭!&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor));</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在刷视频&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务和服务员打饭完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s小白开吃&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码中使用thenCompose，等待厨师线程完成任务后，有返回值后，下一个任务才会触发；此时”番茄炒蛋”返回值会存入dish中，然后开启一个服务员线程（函数式编程中的Function角色），接收厨师线程的返回值，然后进行一系列操作后，return其对应的返回值</p><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745917527573|1|main|小白进入餐厅</span><br><span class="line">1745917527573|1|main|小白点了菜+饭</span><br><span class="line">1745917527576|25|DataProcessor-1|厨师炒菜</span><br><span class="line">1745917527576|1|main|小白在刷视频</span><br><span class="line">1745917527776|26|DataProcessor-2|服务员打饭</span><br><span class="line">1745917527887|1|main|番茄炒蛋饭!小白开吃</span><br></pre></td></tr></table></figure><h4 id="thenCombine（线程同时执行）合并"><a href="#thenCombine（线程同时执行）合并" class="headerlink" title="thenCombine（线程同时执行）合并"></a>thenCombine（线程同时执行）合并</h4><p>该方法会使得不同线程异步同时执行，相当于将不同的线程执行进行合并，并且将线程的返回值进行结合返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白进入餐厅&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白点了菜+饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;番茄炒蛋&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenCombine(CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员蒸饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;米饭!&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor),(dish,rice)-&gt;&#123;<span class="comment">//将厨师线程和服务员线程的参数接受，然后返回结果</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员打饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s+%s&quot;</span>,dish,rice);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在刷视频&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s小白开吃&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1745919339096|1|main|小白进入餐厅</span><br><span class="line">1745919339096|1|main|小白点了菜+饭</span><br><span class="line">1745919339099|25|DataProcessor-1|厨师炒菜</span><br><span class="line">1745919339099|26|DataProcessor-2|服务员蒸饭</span><br><span class="line">1745919339100|1|main|小白在刷视频</span><br><span class="line">1745919339412|26|DataProcessor-2|服务员打饭</span><br><span class="line">1745919339522|1|main|番茄炒蛋+米饭!小白开吃</span><br></pre></td></tr></table></figure><h4 id="exceptionally"><a href="#exceptionally" class="headerlink" title="exceptionally"></a>exceptionally</h4><p>该方法会在supplyAsync执行时，如果执行期间抛出异常，则会直接进入到exceptionally块中，进行对异常处理后返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白吃完饭&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白准备结账&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1进行结账&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;小白跑路了！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;500元&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).exceptionally(e-&gt;&#123;</span><br><span class="line">           smallTool.printTimeAndThread(e.getMessage());</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;工作人员报警&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s,小白被抓了&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1745922097054|1|main|小白吃完饭</span><br><span class="line">1745922097054|1|main|小白准备结账</span><br><span class="line">1745922097057|25|DataProcessor-1|服务员1进行结账</span><br><span class="line">1745922097057|1|main|java.lang.RuntimeException: 小白跑路了！</span><br><span class="line">1745922097057|1|main|工作人员报警,小白被抓了</span><br></pre></td></tr></table></figure><h4 id="allOf"><a href="#allOf" class="headerlink" title="allOf"></a>allOf</h4><p>该方法会在所有的CompletableFuture线程异步执行完任务后，主线程才会进行后续操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt;futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//此处模拟10个线程异步并发执行的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            CompletableFuture&lt;Void&gt;future = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务&quot;</span>+ finalI +<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,dataProcessingExecutor);</span><br><span class="line">            <span class="comment">//将CompletableFuture添加进该list中，只有当list中所有的CompletableFuture执行完任务后allOf才放行</span></span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//allOf方法为主线程会等待所有的CompletableFuture开启的线程执行完任务后，才会进行后续执行</span></span><br><span class="line">        CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务执行完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">任务3完成</span><br><span class="line">任务2完成</span><br><span class="line">任务1完成</span><br><span class="line">任务7完成</span><br><span class="line">任务4完成</span><br><span class="line">任务0完成</span><br><span class="line">任务9完成</span><br><span class="line">任务6完成</span><br><span class="line">任务5完成</span><br><span class="line">任务8完成</span><br><span class="line">所有任务执行完成！</span><br></pre></td></tr></table></figure><h4 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf"></a>anyOf</h4><p>futures中如果有线程已经提前执行完了，那么anyOf就会放行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt;futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//此处模拟10个线程异步并发执行的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            CompletableFuture&lt;Void&gt;future = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务&quot;</span>+ finalI +<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,dataProcessingExecutor);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture.anyOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">        System.out.println(<span class="string">&quot;已有任务执行完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">任务0完成</span><br><span class="line">任务7完成</span><br><span class="line">任务1完成</span><br><span class="line">已有任务执行完成！</span><br><span class="line">任务4完成</span><br><span class="line">任务8完成</span><br><span class="line">任务9完成</span><br><span class="line">任务2完成</span><br><span class="line">任务5完成</span><br><span class="line">任务3完成</span><br><span class="line">任务6完成</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业务的那点事</title>
      <link href="/2025/04/16/%E4%B8%9A%E5%8A%A1%E7%A7%AF%E7%B4%AF/"/>
      <url>/2025/04/16/%E4%B8%9A%E5%8A%A1%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="业务积累"><a href="#业务积累" class="headerlink" title="业务积累"></a>业务积累</h2><h3 id="经纬度定位"><a href="#经纬度定位" class="headerlink" title="经纬度定位"></a>经纬度定位</h3><p>业务中的地图某个点位置是根据经纬度来定位的。但是不同单位使用的地图不一样，可能是百度地图、高德地图等等，但是我们系统中使用的地图只能是一种，所以放入到我们系统中需要进行一个个地图的适配是比较繁琐的，我们统一在后端将不同的地图类型转换为同一个地图类型，然后输出给前端进行响应返回</p><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>当需要对一张表里的某些字段进行加解密时</p><p>先在controller层创建一个加解密接口，参数为：1.表名tabName，2.加解密参数operation(0为需要加密，1为需要解密)</p><p><strong>加密流程：</strong></p><p>然后将该operation参数往下传递，如果operation为0，此时有一张加解密关联表（该表记录了需要加解密的字段），通过遍历该关联表，获取到需要加密的字段，通过SM2算法来进行对字段进行加密（使用SM2算法时，需要先连接密码机，创建连接，生成SM2公钥，进行加密，关闭连接），加密后返回该加密的字段，更新表中原来的字段</p><p><strong>解密流程：</strong></p><p>和加密流程相似</p><p>当operation字段为1，获取关联表中需要加密的字段进行解密（创建连接，连接到密码机后，生成SM2私钥，通过该私钥对字段进行解密，最后关闭连接），返回解密后的数据更新表</p><hr><h2 id="技术积累"><a href="#技术积累" class="headerlink" title="技术积累"></a>技术积累</h2><h3 id="全局异常捕获和状态码返回"><a href="#全局异常捕获和状态码返回" class="headerlink" title="全局异常捕获和状态码返回"></a>全局异常捕获和状态码返回</h3><p><strong>怎么定义全局异常？</strong> </p><p>想要使用全局异常首先需要定义一个<code>GlobalExceptionHandler.java</code>类和自定义异常类<code>DatabaseSetDataException</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseSetDataException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DatabaseSetDataException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(DatabaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Wrapper <span class="title function_">handleDataAccessException</span><span class="params">(DatabaseSetDataException ex)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;数据库操作失败: &quot;</span>+ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> Wrapper.ERROR_BUILDER <span class="comment">//在这里调用wrapper的Eror_builder会将Wrapper里原先设置的code(-1)进行覆盖，不会产生两个code</span></span><br><span class="line">                .code(ex.getCode())</span><br><span class="line">                .message(<span class="string">&quot;操作失败&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Wrapper是什么？</strong></p><p>Wrapper是状态码的统一返回规范类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span><span class="comment">//启用builder构建者模式</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wrapper</span> <span class="keyword">implements</span> <span class="title class_">ResponseRestful</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功响应 Builder</span></span><br><span class="line">    <span class="comment">//如果使用SUCCESS的话，会先调用suc_builder进行拼接code和message</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">WrapperBuilder</span> <span class="variable">SUCCESS_BUILDER</span> <span class="operator">=</span> Wrapper.builder().code(<span class="number">0</span>).data(<span class="number">0</span>).message(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Wrapper</span> <span class="variable">SUCCESS</span> <span class="operator">=</span> SUCCESS_BUILDER.build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用错误 Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">WrapperBuilder</span> <span class="variable">ERROR_BUILDER</span> <span class="operator">=</span> Wrapper.builder().code(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Wrapper</span> <span class="variable">ERROR</span> <span class="operator">=</span> ERROR_BUILDER.message(<span class="string">&quot;ERROR&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会话错误 Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">WrapperBuilder</span> <span class="variable">SESSION_ERROR_BUILDER</span> <span class="operator">=</span> Wrapper.builder().code(<span class="number">510</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Builder构建者模式的使用</strong></p><p>拿上面的Wrapper举例，里面的<code>WrapperBuilder SUCCESS_BUILDER = Wrapper.builder().code(0).data(0).message(&quot;OK&quot;);</code>相当于构建了一个WrapperBuilder对象；只有当<code>Wrapper SUCCESS = SUCCESS_BUILDER.build();</code>使用了builde（）方法，才算是对象构建完成。可以理解为new Wrapper（），然后set属性</p><p><strong>怎么抛出异常，然后被全局异常捕获</strong></p><p>此处是在service层抛出异常，然后被全局异常处理器捕获</p><p>在可能出现异常的地方进行try-catch，catch的异常就是自定义的数据库异常，捕获异常后可以进行对应的异常抛出和处理；当抛出DatabaseSetDataException后会被全局异常处理器捕获到，最后返回对应的错误码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YyAppointmentInfoServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;YyAppointmentInfoMapper, YyAppointmentInfo&gt; <span class="keyword">implements</span> <span class="title class_">IYyAppointmentInfoService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    YyAppointmentInfoMapper yyAppointmentInfoMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataExceptionHandImpl dataExceptionHand;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAppointInfo</span><span class="params">(YyAppointmentInfo appointmentInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            appointmentInfo.setRksj(LocalDateTime.now());</span><br><span class="line">            yyAppointmentInfoMapper.insert(appointmentInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            <span class="comment">//将存入数据异常的对象存入，传入对应的type，异常信息</span></span><br><span class="line">            dataExceptionHand.handleInsertException(appointmentInfo,<span class="number">0</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode更新博客要点</title>
      <link href="/2025/04/15/vscode%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%A6%81%E7%82%B9/"/>
      <url>/2025/04/15/vscode%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo博客更新"><a href="#hexo博客更新" class="headerlink" title="hexo博客更新"></a>hexo博客更新</h2><p>需要新增一篇博客时直接在blog文件夹下hexo new “文件名”</p><hr><h2 id="推送信息"><a href="#推送信息" class="headerlink" title="推送信息"></a>推送信息</h2><p>当在vscode更新时需要每次从本地提交到远程，再重新启动才会生效<br>修改完内容后：</p><ol><li>git add -A(添加到缓冲区)</li><li>git commit -m “此次修改的描述信息”</li><li>git push(推送到远程;如果出现fatal: unable to access ‘<a href="https://github.com/legend578/legend578.github.io.git/">https://github.com/legend578/legend578.github.io.git/</a>‘: Failed to connect to 127.0.0.1 port 7897 after 2107 ms: Could not connect to server则进行开启clash代理)<br>hexo d（使得网站重新生效）</li></ol><hr><h2 id="怎么将博客放入到标签和分类中"><a href="#怎么将博客放入到标签和分类中" class="headerlink" title="怎么将博客放入到标签和分类中"></a>怎么将博客放入到标签和分类中</h2><p>在每篇博客的顶部，进行设置categories和tags，想要将该博客归属到哪，就在下面编写对应文字<br><img src="/img/vscode1.png" width="auto" height="auto"></p><h2 id="怎么在博客中插入图片"><a href="#怎么在博客中插入图片" class="headerlink" title="怎么在博客中插入图片"></a>怎么在博客中插入图片</h2><p>使用<img src="/img/vscode1.png" width="auto" height="auto">，使用img标签即可，src填写图片路径，可以是外部图片，也可以是本机图片</p>]]></content>
      
      
      <categories>
          
          <category> 博客初始化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客怎么更新 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
