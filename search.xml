<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java异常处理机制的使用</title>
      <link href="/2025/07/21/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/07/21/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>一般在代码中Java的异常处理机制使用场景是比较多的，本文围绕Java异常处理机制怎么使用展开</p><h1 id="出现异常后只记录日志"><a href="#出现异常后只记录日志" class="headerlink" title="出现异常后只记录日志"></a>出现异常后只记录日志</h1><p>当程序出现异常，并且捕获后不抛出异常只记录日志，那么整个程序是不断中断的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;准备出现异常====&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;<span class="comment">//模拟出现异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//e.printStackTrace();//使用输出堆栈信息可以显示更完整的错误信息</span></span><br><span class="line">            log.error(<span class="string">&quot;异常：&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompare</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ex();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟程序后续运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行中===&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2025-07-21 11:04:51.580  INFO 22488 --- [           main] c.s.work_test.WorkTestApplicationTests   : 准备出现异常====</span><br><span class="line">2025-07-21 11:04:51.580 ERROR 22488 --- [           main] c.s.work_test.WorkTestApplicationTests   : 异常：/ by zero</span><br><span class="line">程序运行中===</span><br></pre></td></tr></table></figure><h1 id="出现异常后直接中断程序"><a href="#出现异常后直接中断程序" class="headerlink" title="出现异常后直接中断程序"></a>出现异常后直接中断程序</h1><p>该try-catch的处理方式结果和没有try-catch处理的结果都是一样的，异常会直接中断程序然后退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;准备出现异常====&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i= <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//e.printStackTrace();//使用输出堆栈信息可以显示更完整的错误信息</span></span><br><span class="line">            log.error(<span class="string">&quot;异常：&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;异常：&quot;</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompare</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ex();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟程序后续运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行中===&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">2025-07-21 14:13:45.728  INFO 9636 --- [           main] c.s.work_test.WorkTestApplicationTests   : 准备出现异常====</span><br><span class="line">2025-07-21 14:13:45.729 ERROR 9636 --- [           main] c.s.work_test.WorkTestApplicationTests   : 异常：/ by zero</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: 异常：/ by zero</span><br><span class="line"></span><br><span class="line">at com.sky.work_test.WorkTestApplicationTests.ex(WorkTestApplicationTests.java:23)</span><br><span class="line">at com.sky.work_test.WorkTestApplicationTests.testCompare(WorkTestApplicationTests.java:29)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725)</span><br><span class="line">at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)</span><br><span class="line">at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)</span><br><span class="line">at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)</span><br><span class="line">at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)</span><br><span class="line">at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)</span><br><span class="line">at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)</span><br><span class="line">at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)</span><br><span class="line">at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)</span><br><span class="line">at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)</span><br><span class="line">at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)</span><br><span class="line">at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)</span><br><span class="line">at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)</span><br><span class="line">at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)</span><br><span class="line">at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)</span><br><span class="line">at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210)</span><br><span class="line">at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)</span><br><span class="line">at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)</span><br><span class="line">at java.util.ArrayList.forEach(ArrayList.java:1257)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)</span><br><span class="line">at java.util.ArrayList.forEach(ArrayList.java:1257)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)</span><br><span class="line">at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)</span><br><span class="line">at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)</span><br><span class="line">at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)</span><br><span class="line">at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)</span><br><span class="line">at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)</span><br><span class="line">at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86)</span><br><span class="line">at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86)</span><br><span class="line">at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53)</span><br><span class="line">at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:57)</span><br><span class="line">at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)</span><br><span class="line">at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)</span><br><span class="line">at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)</span><br><span class="line">at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)</span><br><span class="line">at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 -1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="出现异常不影响循环处理"><a href="#出现异常不影响循环处理" class="headerlink" title="出现异常不影响循环处理"></a>出现异常不影响循环处理</h1><p>想要让当前数据的异常不影响下一条数据的执行，那么就使用捕获异常输出日志的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">5</span>;n++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//业务逻辑...</span></span><br><span class="line">                log.info(<span class="string">&quot;准备出现异常====&quot;</span>);</span><br><span class="line">                <span class="type">int</span> i= <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//e.printStackTrace();//使用输出堆栈信息可以显示更完整的错误信息</span></span><br><span class="line">                log.error(<span class="string">&quot;异常：&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompare</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ex();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟程序后续运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行中===&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2025-07-21 11:10:52.088  INFO 24888 --- [           main] c.s.work_test.WorkTestApplicationTests   : 准备出现异常====</span><br><span class="line">2025-07-21 11:10:52.088 ERROR 24888 --- [           main] c.s.work_test.WorkTestApplicationTests   : 异常：/ by zero</span><br><span class="line">2025-07-21 11:10:52.089  INFO 24888 --- [           main] c.s.work_test.WorkTestApplicationTests   : 准备出现异常====</span><br><span class="line">2025-07-21 11:10:52.089 ERROR 24888 --- [           main] c.s.work_test.WorkTestApplicationTests   : 异常：/ by zero</span><br><span class="line">2025-07-21 11:10:52.089  INFO 24888 --- [           main] c.s.work_test.WorkTestApplicationTests   : 准备出现异常====</span><br><span class="line">2025-07-21 11:10:52.089 ERROR 24888 --- [           main] c.s.work_test.WorkTestApplicationTests   : 异常：/ by zero</span><br><span class="line">2025-07-21 11:10:52.090  INFO 24888 --- [           main] c.s.work_test.WorkTestApplicationTests   : 准备出现异常====</span><br><span class="line">2025-07-21 11:10:52.090 ERROR 24888 --- [           main] c.s.work_test.WorkTestApplicationTests   : 异常：/ by zero</span><br><span class="line">2025-07-21 11:10:52.090  INFO 24888 --- [           main] c.s.work_test.WorkTestApplicationTests   : 准备出现异常====</span><br><span class="line">2025-07-21 11:10:52.090 ERROR 24888 --- [           main] c.s.work_test.WorkTestApplicationTests   : 异常：/ by zero</span><br><span class="line">程序运行中===</span><br></pre></td></tr></table></figure><h1 id="出现异常中断循环处理程序"><a href="#出现异常中断循环处理程序" class="headerlink" title="出现异常中断循环处理程序"></a>出现异常中断循环处理程序</h1><p>想要让循环中如果出现异常就立马退出循环处理，则就throw抛出异常，将异常交给调用者处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;<span class="number">5</span>;n++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;准备出现异常====&quot;</span>);</span><br><span class="line">                <span class="type">int</span> i= <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//e.printStackTrace();//使用输出堆栈信息可以显示更完整的错误信息</span></span><br><span class="line">                log.error(<span class="string">&quot;异常：&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;异常：&quot;</span>+e.getMessage());<span class="comment">//该异常会抛给调用者</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompare</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//ex()方法的异常到了该处，为了使得程序还能够执行后面的流程，所以需要捕获异常</span></span><br><span class="line">            log.error(<span class="string">&quot;程序发生异常，在此处处理:&quot;</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟程序后续运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行中===&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2025-07-21 11:21:15.285  INFO 25780 --- [           main] c.s.work_test.WorkTestApplicationTests   : 准备出现异常====</span><br><span class="line">2025-07-21 11:21:15.285 ERROR 25780 --- [           main] c.s.work_test.WorkTestApplicationTests   : 异常：/ by zero</span><br><span class="line">2025-07-21 11:21:15.286 ERROR 25780 --- [           main] c.s.work_test.WorkTestApplicationTests   : 程序发生异常，在此处处理:异常：/ by zero</span><br><span class="line">程序运行中===</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo插入的图片无法显示解决</title>
      <link href="/2025/07/05/hexo%E6%8F%92%E5%85%A5%E7%9A%84%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3/"/>
      <url>/2025/07/05/hexo%E6%8F%92%E5%85%A5%E7%9A%84%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="对于Hexo博客的粘贴图片无法插入问题解决"><a href="#对于Hexo博客的粘贴图片无法插入问题解决" class="headerlink" title="对于Hexo博客的粘贴图片无法插入问题解决"></a>对于Hexo博客的粘贴图片无法插入问题解决</h1><p>我使用的是Typora编辑器写的博客，所以该解决方法针对该编辑器来解决</p><h2 id="1-在vscode中先修改根目录下的配置文件-config-yml里的信息"><a href="#1-在vscode中先修改根目录下的配置文件-config-yml里的信息" class="headerlink" title="1.在vscode中先修改根目录下的配置文件&#x2F;_config.yml里的信息"></a>1.在vscode中先修改根目录下的配置文件&#x2F;_config.yml里的信息</h2><p>将post_asset_folder字段修改为true</p><p><img src="/2025/07/05/hexo%E6%8F%92%E5%85%A5%E7%9A%84%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3/image-20250705104822825.png" alt="image-20250705104822825"></p><h2 id="2-修改Typora图片粘贴路径"><a href="#2-修改Typora图片粘贴路径" class="headerlink" title="2.修改Typora图片粘贴路径"></a>2.修改Typora图片粘贴路径</h2><ul><li>进入Typora，文件&#x3D;》偏好设置</li></ul><p><img src="/2025/07/05/hexo%E6%8F%92%E5%85%A5%E7%9A%84%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3/image-20250705104924457.png" alt="image-20250705104924457"></p><ul><li>将图像设置修改为和我的一致</li><li><img src="/2025/07/05/hexo%E6%8F%92%E5%85%A5%E7%9A%84%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3/image-20250705105032102.png" alt="image-20250705105032102"></li></ul><h2 id="3-打开vscode终端控制台，下载插件"><a href="#3-打开vscode终端控制台，下载插件" class="headerlink" title="3.打开vscode终端控制台，下载插件"></a>3.打开vscode终端控制台，下载插件</h2><p>将该条代码放到终端运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><p><img src="/2025/07/05/hexo%E6%8F%92%E5%85%A5%E7%9A%84%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3/image-20250705105311693.png" alt="image-20250705105311693"></p><h2 id="4-重新加载，图片显示成功"><a href="#4-重新加载，图片显示成功" class="headerlink" title="4.重新加载，图片显示成功"></a>4.重新加载，图片显示成功</h2><p>放到终端运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl;hexo g;hexo s</span><br></pre></td></tr></table></figure><p><img src="/2025/07/05/hexo%E6%8F%92%E5%85%A5%E7%9A%84%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3/image-20250705105525563.png" alt="image-20250705105525563"></p><p>最终加载到github更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;update&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl;hexo g;hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java中的数组，集合自定义排序</title>
      <link href="/2025/07/04/java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E9%9B%86%E5%90%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/07/04/java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E9%9B%86%E5%90%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>一般在写算法题时，想要对数组，集合等数据结构自定义排序，该文章对其自定义排序进行了总结</p><h1 id="二维数组自定义排序"><a href="#二维数组自定义排序" class="headerlink" title="二维数组自定义排序"></a>二维数组自定义排序</h1><p>例如现在需要根据二维数组的第一个元素排序</p><p>1.使用重写compare方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompare</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][]arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span>+Arrays.deepToString(arr));</span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">                <span class="comment">//根据二维数组中每个元素的第一个值进行升序排序</span></span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后&quot;</span>+Arrays.deepToString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序前：[[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">6</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">排序后：[[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">6</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>2.使用lambda表达式实现（和重写compare同理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompare</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][]arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span>+Arrays.deepToString(arr));</span><br><span class="line">        Arrays.sort(arr, (o1, o2) -&gt; o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span>+Arrays.deepToString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序前：[[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">6</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">排序后：[[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">6</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><h1 id="集合list自定义排序"><a href="#集合list自定义排序" class="headerlink" title="集合list自定义排序"></a>集合list自定义排序</h1><p>1.使用compare方式</p><p>对list中的元素升序排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompare</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Integer&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">8</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span>+list);</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1-o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序前：[4, 1, 3, 8, 5]</span><br><span class="line">排序后：[1, 3, 4, 5, 8]</span><br></pre></td></tr></table></figure><p>2.使用lambda方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class WorkTestApplicationTests &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testCompare()&#123;</span><br><span class="line">        List&lt;Integer&gt;list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(4);</span><br><span class="line">        list.add(1);</span><br><span class="line">        list.add(3);</span><br><span class="line">        list.add(8);</span><br><span class="line">        list.add(5);</span><br><span class="line">        System.out.println(&quot;排序前：&quot;+list);</span><br><span class="line">        Collections.sort(list, (o1, o2) -&gt; o1-o2);</span><br><span class="line">        System.out.println(&quot;排序后：&quot;+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序前：[4, 1, 3, 8, 5]</span><br><span class="line">排序后：[1, 3, 4, 5, 8]</span><br></pre></td></tr></table></figure><h2 id="根据集合中的对象属性排序"><a href="#根据集合中的对象属性排序" class="headerlink" title="根据集合中的对象属性排序"></a>根据集合中的对象属性排序</h2><p>1.使用compare方式</p><p>定义一个user类，此时需要根据age属性排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompare</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">45</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">28</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">66</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span>+list);</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(User o1, User o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.age-o2.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序前：[WorkTestApplicationTests.User(name=张三, age=45), WorkTestApplicationTests.User(name=李四, age=28), WorkTestApplicationTests.User(name=王五, age=16), WorkTestApplicationTests.User(name=赵六, age=66)]</span><br><span class="line"></span><br><span class="line">排序后：[WorkTestApplicationTests.User(name=王五, age=16), WorkTestApplicationTests.User(name=李四, age=28), WorkTestApplicationTests.User(name=张三, age=45), WorkTestApplicationTests.User(name=赵六, age=66)]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.使用lambda方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class WorkTestApplicationTests &#123;</span><br><span class="line">    @Data</span><br><span class="line">    @AllArgsConstructor</span><br><span class="line">    class User&#123;</span><br><span class="line">        String name;</span><br><span class="line">        int age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testCompare()&#123;</span><br><span class="line">        List&lt;User&gt;list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(new User(&quot;张三&quot;,45));</span><br><span class="line">        list.add(new User(&quot;李四&quot;,28));</span><br><span class="line">        list.add(new User(&quot;王五&quot;,16));</span><br><span class="line">        list.add(new User(&quot;赵六&quot;,66));</span><br><span class="line">        System.out.println(&quot;排序前：&quot;+list);</span><br><span class="line">        Collections.sort(list, (o1, o2) -&gt; o1.age-o2.age);</span><br><span class="line">        System.out.println(&quot;排序后：&quot;+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序前：[WorkTestApplicationTests.User(name=张三, age=45), WorkTestApplicationTests.User(name=李四, age=28), WorkTestApplicationTests.User(name=王五, age=16), WorkTestApplicationTests.User(name=赵六, age=66)]</span><br><span class="line"></span><br><span class="line">排序后：[WorkTestApplicationTests.User(name=王五, age=16), WorkTestApplicationTests.User(name=李四, age=28), WorkTestApplicationTests.User(name=张三, age=45), WorkTestApplicationTests.User(name=赵六, age=66)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP的网络模型</title>
      <link href="/2025/07/04/TCP%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/07/04/TCP%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>参考博客<a href="https://xiaolincoding.com/network/1_base/tcp_ip_model.html#%E5%BA%94%E7%94%A8%E5%B1%82">2.1 TCP&#x2F;IP 网络模型有哪几层？ | 小林coding</a>个人学习笔记</p><h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><p>OSI网络模型有七层：应用层、表现层、会话层、传输层、网络层、数据链路层、物理层；但是OSI网络模型只是一个逻辑概念，一个规范，实际网络中使用的网络模型是TCP&#x2F;IP网络模型</p><p>TCP&#x2F;IP网络模型一般分为四层或五层（都可以）</p><ul><li><p>四层：应用层、传输层、网络层、网络接口层</p></li><li><p>五层：应用层、传输层、网络层、数据链路层、物理层</p></li></ul><h1 id="TCP-IP网络模型剖析（以四层解析）"><a href="#TCP-IP网络模型剖析（以四层解析）" class="headerlink" title="TCP&#x2F;IP网络模型剖析（以四层解析）"></a>TCP&#x2F;IP网络模型剖析（以四层解析）</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li><p>应用层是直接接触到用户的一层，例如网页浏览，手机软件等应用。当不同设备之间需要通信时，就将应用层数据传给下一层（传输层）</p></li><li><p>应用层提供的服务：网页浏览（HTTP、HTTPS），文件传输（FTP），邮件（SMTP）</p></li><li><p>应用层属于用户态，和用户进行交互；传输层及以下几层为内核层，操作系统来控制</p></li></ul><p>例如使用HTTP协议，那么应用层的数据会由HTTP协议进行封装为HTTP报文（HTTP报文：HTTP请求报文+数据）</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ul><li>应用层的数据会传给传输层，传输层为应用层提供网络服务</li><li>传输层具有两个协议TCP、UDP协议：TCP为可靠性传输，具有超时重传、流量控制、拥塞控制等机制；UDP为不可靠性传输，但实时性高，传输效率高</li><li>该层会将应用层传输过来的HTTP报文封装变成TCP报文（TCP报文：TCP报文头+HTTP报文）；TCP报文头里具有源端口和目标端口两个字段，端口是用来区分该报文传输到不同的应用程序使用的</li><li>当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 <strong>TCP 段</strong></li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png" alt="img"></p><p>宏观来看，应用层与应用层之间的通信依靠传输层</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="img"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li>传输层的传输数据细节还需依靠网络层来实现，传输层只负责应用层之间的通信的职责</li><li>网络层会将传输层传过来的TCP报文封装为IP报文，IP报文：IP报文头（具有源IP和目标IP）+TCP报文</li><li>网络层具有的协议：IP协议，ICMP协议，ARP协议等</li></ul><p>（1）IP协议</p><p>IP协议具有寻址和路由功能，寻址：根据IP地址寻找到对应的子网，路由：路由器转发寻址请求到实际目的地</p><p>IP地址分为网络号和主机号：</p><ul><li>网络号：标识设备所属的子网</li><li>主机号：标识设备在子网中具体的主机</li></ul><p>举个栗子：例如192.168.233.1&#x2F;24</p><p>这里的&#x2F;24代表的是子网掩码，表示前24位为网络号，后8位为主机号；在192.168.233.×里的×范围为0-255，这里面的主机号都属于同一子网</p><p>（2）ICMP协议</p><p>ICMP协议用来实现网络诊断功能和纠错功能，例如ping命令就是由ICMP协议实现的</p><p>（3）ARP协议</p><p>通过ARP协议可以根据IP地址寻找到主机对应的MAC地址</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="img"></p><h2 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h2><ul><li>网路接口层将数据链路层和网络层结合到了一起，网络接口层会根据IP地址使用ARP协议寻址到对应的MAC地址，将MAC地址和IP报文拼接到一起变为数据帧</li><li>通过MAC地址可以在一个局域网中寻找到对应的主机，并且将数据帧发送到目的地</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png" alt="img"></p><h2 id="每一层数据的封装格式"><a href="#每一层数据的封装格式" class="headerlink" title="每一层数据的封装格式"></a>每一层数据的封装格式</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>交换机和路由器的区别</title>
      <link href="/2025/07/02/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/07/02/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="交换机和路由器的区别"><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h1><ul><li><p>交换机：工作于数据链路层，主要处理数据帧的转发和交换，交换机根据MAC地址来转发数据包。实现同一局域网内的设备通信</p></li><li><p>路由器：工作于网络层，主要处理IP数据包的转发和路由，路由器根据IP地址来转发数据包，实现不同网络之间的通信</p></li></ul><h1 id="IP地址和MAC地址区别"><a href="#IP地址和MAC地址区别" class="headerlink" title="IP地址和MAC地址区别"></a>IP地址和MAC地址区别</h1><ul><li>IP地址：IP地址用于唯一标识网络空间的设备地址，他是网络层中的地址，实现不同网络的设备通信</li><li>MAC地址：用于唯一标识同一局域网内的设备地址，他是数据链路层的地址，实现同一局域网内的设备通信</li></ul><h1 id="有了IP地址为什么还需要MAC地址？"><a href="#有了IP地址为什么还需要MAC地址？" class="headerlink" title="有了IP地址为什么还需要MAC地址？"></a>有了IP地址为什么还需要MAC地址？</h1><ul><li><p>有IP地址，没有MAC地址：IP地址是根据所在的子网来分配的，DHCP协议为设备动态分配IP地址时，需要通过MAC地址来通信的</p></li><li><p>有MAC地址，没有IP地址：如果不存在IP地址，那么需要路由器记住每个设备所在的子网，那么路由器需要存放每个MAC地址，路由器是存放不下的</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP的可靠性</title>
      <link href="/2025/07/01/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
      <url>/2025/07/01/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">https://xiaolincoding.com/network/3_tcp/tcp_feature.html学习笔记</a></p><h1 id="TCP的可靠性传输"><a href="#TCP的可靠性传输" class="headerlink" title="TCP的可靠性传输"></a>TCP的可靠性传输</h1><h2 id="TCP的可靠性怎么保证？"><a href="#TCP的可靠性怎么保证？" class="headerlink" title="TCP的可靠性怎么保证？"></a>TCP的可靠性怎么保证？</h2><ul><li><p>连接：TCP是面向连接的协议，在建立连接的时候需要三次握手，确保客户端和服务端双方都有发送和接受数据的能力</p></li><li><p>序列号和确认号：序列号可以保证数据传输的有序性；确认号可以保证传输的数据都被接收到，用来实现超时重传机制</p></li><li><p>数据包超时重传机制：当发送的数据包超过一定时间没有得到ACK应答（确认号为序列号+1），那么会进行重传，防止数据包的遗漏和丢失</p></li><li><p>流量控制机制：通过接收方的滑动窗口可以实现流量控制机制，接收方在ACK报文中告知滑动窗口大小，则告诉发送方：接收方还可以接受多少数据，发送方可以根据接收方接受数据的能力调整发送数据的速度</p></li><li><p>拥塞控制机制：拥塞控制作用是为了防止网络中传输的数据包过多，导致数据包的延时和丢失，主要通过慢启动，拥塞避免，拥塞发生，超时重传，快速重传，快速恢复等算法实现拥塞控制</p></li></ul><h2 id="流量控制和拥塞控制的区别"><a href="#流量控制和拥塞控制的区别" class="headerlink" title="流量控制和拥塞控制的区别"></a>流量控制和拥塞控制的区别</h2><ul><li>流量控制：负责端到端的控制，目的是防止发送方发送数据速度过快，接收方处理不过来，而导致发送的数据丢失或延时；通过滑动窗口实现，当接收方响应ACK报文时会告诉发送方自己还能接收数据的大小，发送方根据接收方的能力来发送数据</li><li>拥塞控制：负责网络层面的控制，目的是为了发送方发送的数据包过多，而导致阻塞整个网络空间；发送速度过快会拥塞网络，可能导致数据包传输的延时或丢失，当超时重传后会有更多的数据表累积在网络控制，拥塞情况更加严重；所以需要通过慢启动，拥塞避免，拥塞发生等一些算法来实现拥塞控制</li></ul><h2 id="拥塞控制如何实现？"><a href="#拥塞控制如何实现？" class="headerlink" title="拥塞控制如何实现？"></a>拥塞控制如何实现？</h2><p>主要通过以下几种算法实现：</p><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>首先发送数据时会处于慢启动算法，发送数据大小为拥塞窗口大小（初始化为1，发送窗口&#x3D;min(接收窗口，拥塞窗口)），当每次发送的数据大小等量拥塞窗口大小后，拥塞窗口大小会翻倍增长，处于指数型增长</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="慢启动算法"></p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>当慢启动中的拥塞窗口大小达到慢启动门限（慢启动门限一般是固定的）后，会进入拥塞避免阶段；在拥塞避免阶段，每当发送数据大小等量拥塞窗口大小后，拥塞窗口大小会增加一个报文段大小，处于线性增长，原因是网络中已经存在一部分的数据包，网络可能马上要发送拥塞了，所以降低拥塞窗口增长速度，降低发送方发送的速度</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞避免"></p><h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>随着网络中数据包越来也多，可能发生网络拥塞而导致数据包的丢失，这时候就需要重传机制来找回丢失的数据包；主要包含两种重传机制：超时重传，快速重传</p><h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>当出现超时后，会进行超时重传数据包，并且将慢启动门限设置为当前拥塞窗口大小的一半，将当前拥塞窗口大小设置为初始值1，此时会重新进入慢启动状态，发送速度会降低很多</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞发送 —— 超时重传"></p><h4 id="快速重传（负责处理单个数据包丢失情况）"><a href="#快速重传（负责处理单个数据包丢失情况）" class="headerlink" title="快速重传（负责处理单个数据包丢失情况）"></a>快速重传（负责处理单个数据包丢失情况）</h4><ul><li><p>在超时重传触发前，如果收到了三个重复的ACK报文（说明传输过程中有单个数据包丢失，并不需要像超时重传那样直接将拥塞窗口设置为1，发送速度会大大降低，影响网络传输速度），则会触发快速重传，并且将拥塞窗口大小设置为当前拥塞窗口大小的一半，慢启动门限设置为变化后的拥塞窗口大小</p></li><li><p>快速重传之后会进入快速恢复阶段，将拥塞窗口设置为慢启动门限+3（此时网络空间不是特别拥塞，并且之前已经收到3个重复的ACK报文，说明发送出去三个数据包，但没有被接收到，却又占用拥塞窗口，此时不会重传该三个数据包，由此可以知道拥塞窗口可以再大一些。所以这里尝试+3，让重传的数据尽快发送出去），如果后续还收到重复的ACK则拥塞窗口+1，直到收到新数据的ACK报文后拥塞窗口变为慢启动门限值，之后进入拥塞避免阶段，发送速度不会降低很多</p></li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传和快速恢复"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP的三次握手和四次挥手</title>
      <link href="/2025/06/29/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2025/06/29/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">4.1 TCP 三次握手与四次挥手面试题 | 小林coding</a>学习笔记</p><h1 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h1><p><img src="https://img2018.cnblogs.com/blog/1290987/201906/1290987-20190615111551823-1173939851.png" alt="img"></p><p>TCP报文 &#x3D; TCP头部+TCP数据格式</p><p>TCP头部包含：</p><ul><li>源端口</li><li>目标端口</li><li>序列号（保证TCP报文接收数据顺序和传递顺序是一致的，用来解决数据包乱序问题）</li><li>确认号（用来作为下一次期望收到的序列号，确保这个序号以前的数据包都被正常接收到，解决数据丢包问题）</li><li>等等</li></ul><p>标志位：</p><ul><li>SYN：请求建立连接</li><li>ACK：确认接收到报文，为1时才认为该确认号有效，为0时表示没有确认信息</li><li>FIN：请求断开连接</li><li>RST：由于主机发生宕机等错误原因，该标志位用来重置连接</li></ul><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p><p>TCP三次握手是为了HTTP请求时建立TCP连接</p><p>首先客户端和服务端都处于close状态（close表示没有建立连接，established表示处于连接状态），服务端首先会监听一个端口，处理listen状态</p><h2 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h2><p>客户端会生成一个随机序号，并将该序号放入TCP报文的序列号字段中，对SYN标志位设置为1，这样即表示SYN报文。客户端将其SYN报文发送给服务端，之后客户端处于SYN_SENT状态，这个为TCP第一次握手</p><h2 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h2><p>服务端收到客户端的SYN报文后，会将里面的客户端序号+1作为TCP报文的确认号字段，然后也会随机生成一个序号作为TCP报文的序列号字段，并且将SYN和ACK标志位设置为1。服务端会将SYN-ACK报文发送给客户端，之后服务端处于SYN_received状态。ACK是作为对客户端第一次握手的应答，SYN作为服务端第二次握手的发送请求建立连接信息。这是TCP第二次握手</p><h2 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h2><p>客户端接收到服务端的SYN-ACK报文后，先会检验该报文的确认号是否合法，然后将该报文中的服务端序号+1作为TCP报文的确认号，并且设置ACK字段为1，表示该报文为ACK报文。最后将该报文发送给服务端，之后客户端处于established状态</p><p>服务端收到ACK报文也处于established状态，这是第三次握手</p><h1 id="TCP三次握手过程中丢包怎么办？"><a href="#TCP三次握手过程中丢包怎么办？" class="headerlink" title="TCP三次握手过程中丢包怎么办？"></a>TCP三次握手过程中丢包怎么办？</h1><h2 id="第一次握手丢包"><a href="#第一次握手丢包" class="headerlink" title="第一次握手丢包"></a>第一次握手丢包</h2><p>如果在第一次握手丢包，说明客户端的SYN报文没有发送给服务端。那么客户端会收不到服务端的SYN-ACK报文应答，则会超时重传SYN报文再次请求建立连接。如果达到最大重传次数，客户端会断开连接</p><p>超时重传的时间由操作系统而定，一般为1s；当超时后会进行重传，并且每次超时时间为上一次的2倍，例如1s，2s，4s，8s重传</p><h2 id="第二次握手丢包"><a href="#第二次握手丢包" class="headerlink" title="第二次握手丢包"></a>第二次握手丢包</h2><p>第二次握手丢包，说明服务端的SYN-ACK报文没有发送给客户端。客户端的第一次握手收不到SYN-ACK应答，同时服务端也收不到客户端第二次握手的ACK报文。那么结果就是客户端的第一次握手会超时重传SYN报文给服务端，同时服务端的第二次握手也会超时重传SYN-ACK报文给客户端</p><h2 id="第三次握手丢包"><a href="#第三次握手丢包" class="headerlink" title="第三次握手丢包"></a>第三次握手丢包</h2><p>第三次握手丢包，说明客户端的ACK报文没有发送给服务端。服务端收不到ACK，报文则会在第二次握手的时候超时重传SYN-ACK报文给客户端</p><h1 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h1><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p><p>TCP的四次挥手是为了断开TCP连接，客户端和服务端都可以作为主动关闭连接的一方</p><p>TCP断开连接需要从established状态变为close状态</p><h2 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h2><p>以客户端作为主动关闭连接一方为例，客户端会先发送FIN报文给服务端，之后客户端处于FIN_WAIT_1状态，表示客户端要关闭连接了</p><h2 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h2><p>服务端接收到客户端的FIN报文后，会回复一个ACK报文给客户端，并且处于close_wait状态，表示服务端可能还有数据未发送完</p><p>客户端收到该ACK报文后会处于FIN_wait_2状态，表示客户端等待服务端发送完数据</p><h2 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h2><p>服务端发送完数据，可以关闭连接时会发送FIN报文给客户端，之后处于last_ack状态，表示可以关闭连接等待最后回复</p><h2 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h2><p>客户端收到服务端的FIN报文后，会立马发送ACK应答报文（发送完ACK后会开始time_wait计时）给服务端，然后客户端开始进入time_wait（2MSL时间）状态中等待关闭连接。服务端收到ACK报文后会立马关闭连接</p><h2 id="为什么time-wait状态需要2MSL？"><a href="#为什么time-wait状态需要2MSL？" class="headerlink" title="为什么time_wait状态需要2MSL？"></a>为什么time_wait状态需要2MSL？</h2><p>MSL：报文的最大存活时间</p><p>以下拿客户端作为主动关闭连接方为例</p><ul><li><p>防止本次连接的历史报文影响新连接：将time_wait设置为2MSL是为了保证客户端（第四次握手的ACK）的服务端（第三次握手超时重传的FIN）两端的报文都消失后才断开连接，然后建立新连接</p></li><li><p>保证被动关闭连接方可以正常关闭：当客户端的第四次握手发送ACK报文给服务端，在这个过程中可能存在ACK丢包，则服务端会在第三次握手超时重传FIN报文，并且FIN报文会在第二个MSL内到达客户端。所以ACK报文丢包和超时重传FIN报文，这么一来一回需要2MSL</p></li></ul><h2 id="time-wait过多有什么危害？"><a href="#time-wait过多有什么危害？" class="headerlink" title="time_wait过多有什么危害？"></a>time_wait过多有什么危害？</h2><ul><li>服务端time_wait过多会导致浪费服务端资源，cpu资源，线程资源等</li><li>客户端time_wait过多会导致占满客户端端口，无法对同一个服务端再发起HTTP请求</li></ul><p>客户端的time_wait过多：</p><ul><li>TCP连接是通过TCP四元组来唯一区分的，四元组：源ip，源端口，目标ip，目标端口</li><li>当客户端对同一个服务端（源ip+源端口相同）具有大量time_wait状态时，会占满该客户端的端口资源（客户端端口资源是有限的），TCP连接的四元组不能相同。则客户端无法再对这个服务端建立TCP连接，但是该客户端端口可以对其他服务端建立连接，因为其他服务端的源ip+源端口是不同的</li></ul><p>服务端的time_wait过多：</p><ul><li>服务端只是监听端口，可以容纳许多客户端端口的请求，但是time_wait过多会浪费资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TLS协议</title>
      <link href="/2025/06/19/TLS%E5%8D%8F%E8%AE%AE/"/>
      <url>/2025/06/19/TLS%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>TLS协议是所属于HTTPS中使用的协议</p><h1 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h1><ul><li><p>传输数据形式：HTTP为明文传输数据，外部进行抓包就可以获取请求参数和数据，比较危险；HTTPS引入<strong>SSL&#x2F;TLS协议</strong>（SSL协议是TLS协议的前身），TLS会对数据加密后再传输，安全性高，同时具有数字证书保证传输过程的数据不会被篡改</p></li><li><p>建立连接：HTTP请求之前只需要通过TCP三次握手，而HTTPS请求之前需要通过TCP三次握手后，再通过TLS四次握手</p></li><li><p>端口号：HTTP默认为80端口，HTTPS默认为443端口</p></li><li><p>数字证书：HTTPS通过第三方CA颁发的数字证书来验证请求者的身份和数据是否被篡改；而HTTP不具有数字证书来验证身份</p></li></ul><h1 id="TLS协议作用"><a href="#TLS协议作用" class="headerlink" title="TLS协议作用"></a>TLS协议作用</h1><p>当HTTPS经过TCP三次握手之后，还会进行TLS四次握手</p><p>TLS主要是为了保证数据通信的安全性，不会轻易将数据的明文形式显示出来</p><h2 id="TLS的加密算法"><a href="#TLS的加密算法" class="headerlink" title="TLS的加密算法"></a>TLS的加密算法</h2><h3 id="1-对称加密算法"><a href="#1-对称加密算法" class="headerlink" title="1.对称加密算法"></a>1.对称加密算法</h3><ul><li><p>该算法只有一个密钥（该密钥不能明文传递），通过该密钥可以对数据进行加密和解密操作</p></li><li><p>适用于对大量数据加解密操作（加解密速度快）</p></li><li><p>AES、DES算法</p></li></ul><h3 id="2-非对称加密算法"><a href="#2-非对称加密算法" class="headerlink" title="2.非对称加密算法"></a>2.非对称加密算法</h3><ul><li><p>该算法具有一对密钥（公钥和私钥），一般使用公钥对数据加密，使用私钥对数据解密。公钥可以随意分发，私钥需要保护起来</p></li><li><p>适用于对少量数据加解密（加解密速度较慢）；一般用于密钥交换和数字签名</p></li><li><p>RSA、ECC算法</p></li></ul><h3 id="3-哈希算法"><a href="#3-哈希算法" class="headerlink" title="3.哈希算法"></a>3.哈希算法</h3><ul><li>哈希算法是一种单向算法，可以通过哈希算法对数据进行哈希计算生成哈希数据，该哈希数据不能被解密来获取原始数据，只能通过相同的哈希算法对原始数据计算后得到哈希值来比对是否相同</li><li>适用于校验数据完整性</li><li>MD5算法</li></ul><h2 id="HTTPS的混合加密"><a href="#HTTPS的混合加密" class="headerlink" title="HTTPS的混合加密"></a>HTTPS的混合加密</h2><p>HTTPS将对称加密和非对称加密混合使用</p><ul><li>首先使用非对称加密算法来交换“对称密钥”</li><li>后续整个通信过程中，使用该“对称密钥”对明文数据对称加密后再传输</li></ul><h1 id="TLS四次握手"><a href="#TLS四次握手" class="headerlink" title="TLS四次握手"></a>TLS四次握手</h1><p>当客户端和服务端TCP三次握手后，会进行TLS四次握手</p><h2 id="TLS第一次握手"><a href="#TLS第一次握手" class="headerlink" title="TLS第一次握手"></a>TLS第一次握手</h2><p>客户端对服务端发送hello信息，并生成一个随机数和密码套件传递过去</p><h2 id="TLS第二次握手"><a href="#TLS第二次握手" class="headerlink" title="TLS第二次握手"></a>TLS第二次握手</h2><p>服务端收到客户端消息后，会选择一套合适的密码套件（密钥交换算法、签名算法、对称加密算法、摘要算法），生成第二个随机数，还有其服务端对应的数字证书一并发送给客户端</p><h3 id="数字证书–保证公钥持有者身份不被冒充"><a href="#数字证书–保证公钥持有者身份不被冒充" class="headerlink" title="数字证书–保证公钥持有者身份不被冒充"></a>数字证书–保证公钥持有者身份不被冒充</h3><ul><li><p>数字证书中包含服务端公钥和CA公钥，CA公钥是用来解密数字证书的，校验数字证书是否合法，而服务端公钥可以直接从数字证书中取出，用于后续非对称加密算法；数字证书的作用是用来认证公钥持有者身份，防止公钥被冒充发送给客户端</p></li><li><p>数字证书通过CA机构（相当于网络世界的公安局）颁发，具有可信度</p></li></ul><h2 id="TLS第三次握手"><a href="#TLS第三次握手" class="headerlink" title="TLS第三次握手"></a>TLS第三次握手</h2><ul><li><p>在进行第三次握手前，会使用CA公钥校验数字证书是否合法，然后从数字证书中取出服务端公钥</p></li><li><p>客户端会生成第三个随机数，使用服务端公钥加密后传输给服务端，服务端用私钥解密得到第三个随机数，此时客户端和服务端都拥有了三个随机数</p></li><li><p>客户端和服务端双方都根据这三个随机数生成对称密钥；然后客户端发送开始使用对称加密的消息给服务端，并且对之前所有的数据做个摘要，然后对称加密一下发送给服务端校验，校验对称加密是否可用，和数据是否被篡改</p></li></ul><h2 id="TLS第四次握手"><a href="#TLS第四次握手" class="headerlink" title="TLS第四次握手"></a>TLS第四次握手</h2><p>服务端同样地，也向客户端发送准备开始使用对称加密的消息，然后对之前的数据做个摘要，对称加密后发送给客户端，客户端校验成功后则完成四次握手</p><p><strong>TLS四次握手成功后，则开始使用对称加密算法加密数据后传输</strong></p><h3 id="数字签名–防止数据被篡改或者身份被冒充"><a href="#数字签名–防止数据被篡改或者身份被冒充" class="headerlink" title="数字签名–防止数据被篡改或者身份被冒充"></a>数字签名–防止数据被篡改或者身份被冒充</h3><p><a href="https://blog.csdn.net/TheSkyLee/article/details/108699243">一文彻底搞懂加密、数字签名和数字证书，看不懂你打我！-CSDN博客</a>参考本文</p><p><strong>加密只能确保数据不被监听</strong></p><ul><li><p>假设Alice是接收方，Bob是发送方</p></li><li><p>黑客也可以使用 Alice 的公钥冒充 Bob 给 Alice 发邮件啊，因为 Alice 的公钥本来就是公开的，任何人都可以获得。</p></li><li><p>由于 黑客 也可以获得 Alice 公钥，所以没法防止 黑客 伪造和篡改，并且对于 Alice 而言，她无法分辨出邮件到底是 Eve 发的还是 Bob</p></li></ul><p>所以需要数字签名，私钥加密，公钥解密</p><ul><li><p>首先Bob将公钥发送给Alice，然后后续传输数据使用私钥对内容数字签名</p></li><li><p>Bob 自己的私钥，Bob 用自己的私钥对邮件内容计算一个「签名」，将「签名」和邮件内容一起发送出去，接受者 Alice 可以使用 Bob 的公钥验证这个签名是否正确，这就叫「验签」（发送方和接收方都拥有自己的一对公钥、私钥）</p></li></ul><h4 id="数字签名的计算"><a href="#数字签名的计算" class="headerlink" title="数字签名的计算"></a>数字签名的计算</h4><p>一般做法是先将原数据进行 Hash 运算（hash算法），得到的 Hash 值就叫做「摘要」。</p><p>「摘要」就像人的指纹一样，可以代表一个人，只要内容发生了改变，计算出来的摘要也应该变化。</p><p>「摘要」最好是不可逆转的，一般使用开头提到的 MD5 作为 Hash 函数，MD5 输出的结果固定位 128 位</p><p>哈希算法得到的数字签名是不可逆的</p><p>为什么「摘要」最好是不可逆转的？</p><p>因为既然 Alice 可以用 Bob 公钥解开签名，那么理论上其它人，比如 Eve 也可以使用 Bob 公钥解开签名拿到数据。</p><p>所以我们最好对数据的「摘要」进行签名，这样，Eve 就算解开签名，拿到的也是「摘要」，如果摘要是不可逆转的，也就是无法从摘要反推出原文，也就达到了保密的作用。</p><p>再通过对得到的摘要使用私钥加密后得到数字签名</p><h4 id="怎么使用数字签名验证身份"><a href="#怎么使用数字签名验证身份" class="headerlink" title="怎么使用数字签名验证身份"></a>怎么使用数字签名验证身份</h4><p>发送数据会有数字签名+数据内容</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3db302430cf6b000ea0059c8ae2629b3.png" alt="img"></p><ul><li>接受者 Alice 收到后，取下数字签名，同时用 Bob 的公钥解密，得到「摘要1」，证明确实是 Bob 发的。</li></ul><p>( 画外音：如果使用 Bob 的公钥验证签名出错，那么签名一定不是 Bob 的私钥生成的）</p><ul><li><p>再对邮件内容使用相同的散列函数计算「摘要2」，与上面得到的「摘要1」进行对比，两者一致就说明信息未被篡改。</p></li><li><p>数字签名是通过对邮件正文哈希计算，然后使用私钥加密而生成的，所以使用公钥解密数字签名后，得到的是哈希计算后的邮件正文</p></li></ul><p>这样两部分证明发送者身份和保证数据未被篡改。</p><h3 id="数字证书–防止数字签名的时候公钥被冒充"><a href="#数字证书–防止数字签名的时候公钥被冒充" class="headerlink" title="数字证书–防止数字签名的时候公钥被冒充"></a>数字证书–防止数字签名的时候公钥被冒充</h3><p>因为数字签名之前，发送方需要先给接收方发送公钥，后续对自己的私钥进行数字签名</p><p><strong>但是这一切的根基是建立在 Alice 持有的公钥确实是Bob的，反之亦然。</strong></p><p>什么意思呢？</p><p>试想，<strong>黑客如果将自己的公钥冒充 Bob 发送给 Alice，然后 Alice 保存了下来，那以后凡是 Bob 发送的消息，反而会验证签名失败，被当做冒充者。</strong></p><p>前面的数字签名是为了防止数据被篡改和冒充，现在的数字证书是为了数字签名过程中防止公钥被篡改和冒充</p><p>数字证书就是公钥的数字签名</p><h4 id="数字证书怎么实现的"><a href="#数字证书怎么实现的" class="headerlink" title="数字证书怎么实现的"></a>数字证书怎么实现的</h4><ul><li><p>而防篡改的方法就是数字签名，但是这个签名不能我们自己做，原因说过了，因为我们的公钥还没分发出去，别人无法验证。</p></li><li><p>所以只能找可信的第三方来帮我们签名，即证书颁布机构（CA），CA 会将：证书的颁布机构、有效期、公钥、持有者(subject)等信息用 CA 的私钥进行签名。</p></li></ul><p>并且将签名结果和这些信息放在一起，这就叫做「数字证书」。</p><ul><li><p>这样，Bob 就可以去 CA 申请一个证书，然后将自己的证书发给 Alice，那么 Alice 如何验证这个证书确实是 Bob的呢？</p></li><li><p>当然是使用 CA 的公钥进行验签。（CA来保证数字证书是合法的，数字证书的信息都通过CA的私钥进行签名）；而服务端公钥则是放在数字证书中可以直接取出</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>http协议的不同版本区别</title>
      <link href="/2025/06/19/http%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/06/19/http%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-1-0和HTTP-1-1的区别"><a href="#HTTP-1-0和HTTP-1-1的区别" class="headerlink" title="HTTP&#x2F;1.0和HTTP&#x2F;1.1的区别"></a>HTTP&#x2F;1.0和HTTP&#x2F;1.1的区别</h1><p>相比于HTTP1.0，HTTP1.1有以下优点：</p><ul><li>默认长连接：HTTP1.0版本支持长连接，但是默认为短连接，而1.1版本默认为长连接</li><li>请求管道化：在1.0版本中，请求和响应都是串行的，需要等待请求和响应都完成后，才可以发起下一次http请求；在1.1版本中，支持请求管道化，http请求可以并行发送，但是响应还是需要按照顺序进行</li><li>增加host字段：1.1版本中在请求头中增加host字段，使得一台服务器可以容纳多个域名</li></ul><h1 id="HTTP-1-1和HTTP-2-0"><a href="#HTTP-1-1和HTTP-2-0" class="headerlink" title="HTTP&#x2F;1.1和HTTP&#x2F;2.0"></a>HTTP&#x2F;1.1和HTTP&#x2F;2.0</h1><p>相比对HTTP1.1，HTTP2.0有以下优点：</p><ul><li>请求和响应都可以并行处理：HTTP1.1的响应不能并行处理，只能按照顺序单个逐一处理；HTTP2.0使用stream（通过stream ID在TCP连接中构建有序的HTTP数据），每个stream对应一个http的请求和响应，多个stream可以复用同一个TCP连接，所以可以并行处理http的请求和响应</li><li>压缩头部和二进制传输：HTTP2.0使用算法压缩了请求头部，并且数据以二进制形式传输，HTTP1.1以超文本形式传输&#x3D;》所以HTTP2.0传输效率更高</li></ul><h1 id="HTTP-2-0和HTTP-3-0"><a href="#HTTP-2-0和HTTP-3-0" class="headerlink" title="HTTP&#x2F;2.0和HTTP&#x2F;3.0"></a>HTTP&#x2F;2.0和HTTP&#x2F;3.0</h1><p>相比对于HTTP2.0，HTTP3.0有以下优点：</p><ul><li>使用的协议不同：HTTP2.0使用TCP协议；而HTTP3.0使用UDP协议，但由于UDP的不可靠传输，所以在应用层中实现了QUIC协议来保证UDP传输的连接管理，拥塞控制，流量控制等功能</li></ul><p>QUIC解决问题：</p><ul><li><strong>解决HTTP2.0中队头阻塞问题</strong>：由于2.0版本中stream有先后顺序，所以当处于前面的stream丢包，后续的stream也需要等待前面的stream处理完成后，才可以后面的stream；而在QUIC中的stream都是没有依赖关系的，所以并行传输时不会互相影响</li><li><strong>TCP 和 TLS 握手时延</strong>：2.0版本中的TCP 三次握手和 TLS 四次握手，共有 3-RTT 的时延；3.0版本中只需要进行TCP三次握手和TLS握手建立，只有一个RTT时延</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http版本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空指针异常的原因和解决</title>
      <link href="/2025/05/30/%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
      <url>/2025/05/30/%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>起因是在将数据库的数据查询出来进行操作时，抛出了空指针异常</p><p>一开始为了防止操作空值，从数据库中查询到encData数据进行操作前判空</p><p>结果发现在判空的时候就已经空指针异常了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(encData))&#123;</span><br><span class="line">    log.error(encStr+<span class="string">&quot;解密的数据为空！&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据库查询的数据分为两种空：null和空白值</p><p>使用空白值进行操作是不会空指针异常的，但是使用null来调用isEmpty则会抛出空指针异常</p><p><strong>解决方法：</strong></p><p>使用org.apache.commons.lang3.StringUtils工具类进行判空即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(encData))&#123;</span><br><span class="line">    log.error(encStr+<span class="string">&quot;解密的数据为空！&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="什么情况会导致空指针异常？"><a href="#什么情况会导致空指针异常？" class="headerlink" title="什么情况会导致空指针异常？"></a>什么情况会导致空指针异常？</h1><h2 id="使用null调用方法"><a href="#使用null调用方法" class="headerlink" title="使用null调用方法"></a>使用null调用方法</h2><p>将字符串置为“”，这不是一个null值，是可以正常操作的</p><p>将字符串置为null，将该空值调用方法时都会抛出空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">nul</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(str.length());<span class="comment">//正常输出0</span></span><br><span class="line">System.out.println(nul.length());<span class="comment">//抛出空指针异常</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">nul</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(str.isEmpty());<span class="comment">//输出true</span></span><br><span class="line">System.out.println(nul.isEmpty());<span class="comment">//抛出空指针异常</span></span><br></pre></td></tr></table></figure><p>可以从上面例子看出：只要是以 null值.方法（）这种方式调用方法都会抛出空指针异常</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>使用org.apache.commons.lang3.StringUtils工具类进行判空后再进行操作</p><p>该工具类所属依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于null值特殊处理：抛出异常信息或抛出错误日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">nul</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(nul))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;this is null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(nul.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况也会被判断为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String nul = &quot;&quot;;</span><br><span class="line">if(StringUtils.isEmpty(nul))&#123;</span><br><span class="line">System.out.println(&quot;this is null&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">System.out.println(nul.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cookie,Session,Jwt之间的区别和使用</title>
      <link href="/2025/05/19/Cookie-Session-Jwt%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/05/19/Cookie-Session-Jwt%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要Cookie和Session"><a href="#为什么需要Cookie和Session" class="headerlink" title="为什么需要Cookie和Session"></a>为什么需要Cookie和Session</h1><p>原因：由于HTTP是无状态的，HTTP的每个请求都是独立的，服务器不会保存客户端之前的请求和会话状态，所以单单依靠HTTP，是无法实现用户登录后，访问其他页面也是使用之前的登录状态，而是会跳转到重新登录页面。</p><p>所以需要Cookie和Session来实现用户登录状态的保存！</p><h2 id="Cookie和Session的使用"><a href="#Cookie和Session的使用" class="headerlink" title="Cookie和Session的使用"></a>Cookie和Session的使用</h2><p>1.用户登录时将用户名和密码传递给服务端进行校验身份</p><p>2.校验身份成功后，服务端会创建一个session对象用来存储用户信息（session保存在内存中），并返回一个session_id给客户端</p><p>3.客户端将session_id存入cookie中，后续客户端每次进行访问该服务端进行携带该session_id即可</p><p>4.服务端接受到session_id后，根据该id去查询之前保存的session信息</p><img src="/2025/05/19/Cookie-Session-Jwt%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/Users\彭思凯\AppData\Roaming\Typora\typora-user-images\image-20250519175704245.png" alt="image-20250519175704245" style="zoom:80%;"><h2 id="使用Cookie和Session保存用户状态的缺点"><a href="#使用Cookie和Session保存用户状态的缺点" class="headerlink" title="使用Cookie和Session保存用户状态的缺点"></a>使用Cookie和Session保存用户状态的缺点</h2><p>session是保存在服务器的内存中的。当服务端部署的机器是集群的情况，那么这些机器都需要保存相同的session信息，如果有一台机器没有保存到该session信息，那么进行负载均衡访问该机器时，就会跳转到登录页面重新登录</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>1.使用MySQL和Redis来保存用户信息</strong></p><p>由于session保存在内存中，所以服务端是集群的情况时，需要全都同步该session信息。所以可以使用数据库保存session_id，当用户传递一个session_id过来时，服务端可以去数据库查询是否存在该session_id来判断用户的登录状态。缺点：存在单点故障（如果数据库宕机，则保存的信息就访问不到或者丢失，如果部署数据库集群又会过于麻烦）</p><p><strong>2.使用JWT来进行无状态登录</strong></p><p>JWT工作流程：</p><p>1.用户登录时将用户名和密码传递给服务端，服务端校验用户身份成功后会生成JWT返回给客户端</p><p>2.客户端将该JWT保存在本地，之后每次访问服务端时都在请求头中携带该JWT（JWT只会存放在客户端中，服务端只负责检验JWT是否合法，可以从JWT中获取到用户会话信息等，所以服务端无需存储JWT，实现无状态）</p><p>3.服务端接受到客户端请求后，从请求头中提取出JWT内容</p><p>4.验证JWT签名：</p><ul><li>服务端使用预存的密钥（服务器统一密钥，对于不同的客户端都使用相同的密钥），结合JWT中的头部、负荷、密钥使用算法生成签名。</li><li>对比生成的签名与 JWT 中的第三段（签名段）是否一致</li></ul><p>5.JWT中包含过期时间和用户会话信息等</p><p><strong>客户端保存的JWT格式(Authorization)：Header.Payload.Signature</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /restful/products/1 HTTP/1.1</span><br><span class="line">Host: icyfenix.cn</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Authorization: Bearer eyJhbGciOiJXVCJ9.eyJ1c2VyXpeCJ9.539WMzbAn8bheflL8</span><br></pre></td></tr></table></figure><img src="/2025/05/19/Cookie-Session-Jwt%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/Users\彭思凯\AppData\Roaming\Typora\typora-user-images\image-20250519180502861.png" alt="image-20250519180502861"><h2 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h2><p>存储位置：Cookie存放在本地浏览器中，session存储在服务端中</p><p>存储大小：Cookie存放在浏览器中，大小是有限制的，不能超过4K；而session存储大小没有限制</p><p>安全性：因为Cookie存放在浏览器中，安全性较低；session存放在服务端中，安全性高一点</p><p>有效时间：Cookie有效时间比session长</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用FastJson来进行JSON和Java数据互相转换</title>
      <link href="/2025/05/16/JSON%E5%92%8CJava%E6%95%B0%E6%8D%AE%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"/>
      <url>/2025/05/16/JSON%E5%92%8CJava%E6%95%B0%E6%8D%AE%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>使用alibaba的fastjson来进行转换</p><p>需要先导入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="解析JSON数据"><a href="#解析JSON数据" class="headerlink" title="解析JSON数据"></a>解析JSON数据</h1><p>拿以下的json数据进行举例，一层层解析json对象和json数组，最终得到picUrl的值</p><p>解析过程：获取到该字符串&#x3D;》解析该字符串为json对象&#x3D;》解析该json对象中的json数组list&#x3D;》解析list数组中的元素（json对象）&#x3D;》通过解析出来的json对象，再进行解析faces的json数组&#x3D;》解析faces中的元素（json对象）&#x3D;》通过解析出来的json对象获取到picUrl的值</p><p>{}表示这是一个json对象，[]表示这是一个json数组</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="comment">//json对象</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SUCCESS&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="comment">//json对象</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pageSize&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pageNo&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//json数组</span></span><br><span class="line">      <span class="punctuation">&#123;</span><span class="comment">//json对象</span></span><br><span class="line">        <span class="attr">&quot;humanId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7d29167378d_08866a80c&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;faces&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//json数组</span></span><br><span class="line">          <span class="punctuation">&#123;</span><span class="comment">//json对象</span></span><br><span class="line">            <span class="attr">&quot;photoId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;80270rfyh29hf299u9&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;photocUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://127.0.0.1:8080/pic?4dda-16e4611i4c33pb&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;bornTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2011-06-10&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;residenceCountyCode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;330602&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>1.首先调用接口获取这么一串字符串</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">params.<span class="title function_">put</span>(<span class="string">&quot;sfz&quot;</span>, data.<span class="title function_">get</span>(idNumberName));</span><br><span class="line">params.<span class="title function_">put</span>(<span class="string">&quot;type&quot;</span>, <span class="keyword">type</span>);</span><br><span class="line"><span class="title class_">String</span> res = easyOkClient.<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:8891/test&quot;</span>, params);</span><br></pre></td></tr></table></figure><p><strong>2.校验res是否合法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(res)) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;接口返回结果为空&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.将res字符串解析为<strong><strong>json</strong></strong>对象(resObject )</strong></p><p>json数据最外层的{}表示这是一个json对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JSONObject</span> <span class="variable">resObject</span> <span class="operator">=</span> JSONObject.parseObject(res);</span><br></pre></td></tr></table></figure><p><strong>4.解析<strong><strong>json</strong></strong>对象(resObject )中的字符串</strong></p><p>因为前面已经获取到了最外层的json对象，所以可以通过该json对象使用getString方法来获取json对象里的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;code&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="string">&quot;0&quot;</span>.equals(code)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">    log.warn(<span class="string">&quot;接口调用失败，code=&#123;&#125;, message=&#123;&#125;&quot;</span>, code, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.解析<strong><strong>json</strong></strong>对象(resObject )里的json对象(dataObj)</strong></p><p>因为在在外层的json对象里的data存在{}，说明data也是一个json对象，通过getJSONObject来获取json对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span><span class="built_in">Object</span> dataObj = jsonObject.<span class="title function_">getJSONObject</span>(<span class="string">&quot;data&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (dataObj == <span class="literal">null</span>) &#123;</span><br><span class="line">    log.<span class="title function_">warn</span>(<span class="string">&quot;data 字段为空&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.解析<strong><strong>json</strong></strong>对象（dataObj）里的json数组（faces）</strong></p><p>在data的json对象里的faces是一个json数组，所以通过getJSONArray来获取json对象中的json数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span><span class="built_in">Array</span> listArray = dataObj.<span class="title function_">getJSONArray</span>(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (listArray == <span class="literal">null</span> || listArray.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    log.<span class="title function_">warn</span>(<span class="string">&quot;list 数组为空&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.获取<strong><strong>json</strong></strong>数组（listArray）中的元素（json对象&#x2F;String字符串）</strong></p><p>以下情况为json数组中存在json对象（因为在示例中，faces:[{},{}]，说明faces数组里存放的是json对象；如果faces:[“”,””]这样的情况，那么直接通过faces.getString就可以获取数组中的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; listArray.<span class="title function_">size</span>(); i++) &#123;</span><br><span class="line">    <span class="title class_">JSON</span><span class="built_in">Object</span> person = listArray.<span class="title function_">getJSONObject</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">JSON</span><span class="built_in">Array</span> faces = person.<span class="title function_">getJSONArray</span>(<span class="string">&quot;faces&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (faces != <span class="literal">null</span> &amp;&amp; !faces.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; faces.<span class="title function_">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">//先获取faces数组中的json对象</span></span><br><span class="line">            <span class="title class_">JSON</span><span class="built_in">Object</span> face = faces.<span class="title function_">getJSONObject</span>(j);</span><br><span class="line">            <span class="comment">//通过getString来获取json对象中的字符串值</span></span><br><span class="line">            <span class="title class_">String</span> picUrl = face.<span class="title function_">getString</span>(<span class="string">&quot;picUrl&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="title class_">StringUtils</span>.<span class="title function_">isEmpty</span>(picUrl)) &#123;</span><br><span class="line">                log.<span class="title function_">info</span>(<span class="string">&quot;提取到的 picUrl：&#123;&#125;&quot;</span>, picUrl);</span><br><span class="line">                <span class="keyword">return</span> picUrl; <span class="comment">// 返回第一个有效 url</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java和JSON数据互转"><a href="#Java和JSON数据互转" class="headerlink" title="Java和JSON数据互转"></a>Java和JSON数据互转</h1><h2 id="Java对象转为JSON字符串"><a href="#Java对象转为JSON字符串" class="headerlink" title="Java对象转为JSON字符串"></a>Java对象转为JSON字符串</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.<span class="property">alibaba</span>.<span class="property">fastjson</span>.<span class="property">JSON</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个Java对象</span></span><br><span class="line">        <span class="title class_">User</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.<span class="title function_">setId</span>(<span class="number">1</span>);</span><br><span class="line">        user.<span class="title function_">setName</span>(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">        user.<span class="title function_">setEmail</span>(<span class="string">&quot;john.doe@example.com&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 使用Fastjson将Java对象转换为JSON字符串</span></span><br><span class="line">        <span class="title class_">String</span> jsonString = <span class="title class_">JSON</span>.<span class="title function_">toJSONString</span>(user);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(jsonString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> int id;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> email;</span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON字符串转为Java对象"><a href="#JSON字符串转为Java对象" class="headerlink" title="JSON字符串转为Java对象"></a>JSON字符串转为Java对象</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.<span class="property">alibaba</span>.<span class="property">fastjson</span>.<span class="property">JSON</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">// JSON字符串</span></span><br><span class="line">        <span class="title class_">String</span> jsonString = <span class="string">&quot;&#123;\&quot;email\&quot;:\&quot;john.doe@example.com\&quot;,\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;John Doe\&quot;&#125;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 使用Fastjson将JSON字符串转换为Java对象</span></span><br><span class="line">        <span class="title class_">User</span> user = <span class="title class_">JSON</span>.<span class="title function_">parseObject</span>(jsonString, <span class="title class_">User</span>.<span class="property">class</span>);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(user.<span class="title function_">getName</span>()); <span class="comment">// 输出 John Doe</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> int id;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> email;</span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java对象和JSONObject相互转换"><a href="#Java对象和JSONObject相互转换" class="headerlink" title="Java对象和JSONObject相互转换"></a>Java对象和JSONObject相互转换</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.<span class="property">alibaba</span>.<span class="property">fastjson</span>.<span class="property">JSON</span>;</span><br><span class="line"><span class="keyword">import</span> com.<span class="property">alibaba</span>.<span class="property">fastjson</span>.<span class="property">JSONObject</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个Java对象</span></span><br><span class="line">        <span class="title class_">User</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.<span class="title function_">setId</span>(<span class="number">1</span>);</span><br><span class="line">        user.<span class="title function_">setName</span>(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">        user.<span class="title function_">setEmail</span>(<span class="string">&quot;john.doe@example.com&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Java对象转JSONObject</span></span><br><span class="line">        <span class="title class_">JSON</span><span class="built_in">Object</span> jsonObject = (<span class="title class_">JSON</span><span class="built_in">Object</span>) <span class="title class_">JSON</span>.<span class="title function_">toJSON</span>(user);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(jsonObject.<span class="title function_">getString</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// 输出 John Doe</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// JSONObject转Java对象</span></span><br><span class="line">        <span class="title class_">User</span> userFromJson = <span class="title class_">JSON</span>.<span class="title function_">toJavaObject</span>(jsonObject, <span class="title class_">User</span>.<span class="property">class</span>);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(userFromJson.<span class="title function_">getName</span>()); <span class="comment">// 输出 John Doe</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> int id;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> email;</span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大量数据批量存入的性能优化</title>
      <link href="/2025/04/29/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2025/04/29/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>当在数据量比较大需要插入时，进行逐条插入MySQL可能会速度很慢，所以这时有几种思路来进行优化</p><h2 id="1-使用mybatisPlus的saveBatch方法进行批量插入"><a href="#1-使用mybatisPlus的saveBatch方法进行批量插入" class="headerlink" title="1.使用mybatisPlus的saveBatch方法进行批量插入"></a>1.使用mybatisPlus的saveBatch方法进行批量插入</h2><p><strong>service调用</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookMapper, Book&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concurrentBatchInsert</span><span class="params">(List&lt;Book&gt; books, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据分片，需要引入hutool依赖，给books中的100w数据进行分片，每个list子集合1000条数据</span></span><br><span class="line">        List&lt;List&lt;Book&gt;&gt; batches = ListUtil.partition(books, batchSize);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Book&gt; batch : batches) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始批量插入数据&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.saveBatch(batch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;耗费时间：&quot;</span>+String.valueOf(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：34723ms</span><br></pre></td></tr></table></figure><h2 id="2-使用foreach进行sql拼接，来进行批量插入"><a href="#2-使用foreach进行sql拼接，来进行批量插入" class="headerlink" title="2.使用foreach进行sql拼接，来进行批量插入"></a>2.使用foreach进行sql拼接，来进行批量插入</h2><p><strong>service调用逻辑</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookMapper, Book&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concurrentBatchInsert</span><span class="params">(List&lt;Book&gt; books, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据分片，需要引入hutool依赖，给books中的10w数据进行分片，每个list子集合1000条数据</span></span><br><span class="line">        List&lt;List&lt;Book&gt;&gt; batches = ListUtil.partition(books, batchSize);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Book&gt; batch : batches) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始批量插入数据&quot;</span>);</span><br><span class="line">            bookMapper.insertBatchSomeColumn(batch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;耗费时间：&quot;</span>+String.valueOf(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapper接口层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Book&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertBatchSomeColumn</span><span class="params">(<span class="meta">@Param(&quot;batch&quot;)</span> List&lt;Book&gt; batch)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapper.xml</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.sky.work_test.mapper.BookMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">&quot;insertBatchSomeColumn&quot;</span>&gt;</span><br><span class="line">        INSERT INTO <span class="title function_">book</span> <span class="params">(bkname,sid,price,author,sur)</span></span><br><span class="line">        VALUES</span><br><span class="line">        &lt;foreach collection=<span class="string">&quot;batch&quot;</span> item=<span class="string">&quot;item&quot;</span> separator=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">            (#&#123;item.bkname&#125;, #&#123;item.sid&#125;,#&#123;item.price&#125;,#&#123;item.author&#125;,#&#123;item.sur&#125;)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：29760ms</span><br></pre></td></tr></table></figure><h2 id="3-在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务"><a href="#3-在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务" class="headerlink" title="3.在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务"></a>3.在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务</h2><p><strong>此处使用线程池异步并发来处理批量任务插入，插入方法可以是sql拼接或者mybatisPlus的saveBatch</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookMapper, Book&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor  dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span><span class="comment">//异步执行</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concurrentBatchInsert</span><span class="params">(List&lt;Book&gt; books, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">        <span class="comment">//创建list集合接受线程的返回值</span></span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据分片，需要引入hutool依赖，给books中的100w数据进行分片，每个list子集合存放1000条数据</span></span><br><span class="line">        List&lt;List&lt;Book&gt;&gt; batches = ListUtil.partition(books, batchSize);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Book&gt; batch : batches) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始批量插入数据&quot;</span>);</span><br><span class="line">            <span class="comment">//开启多个线程并行执行</span></span><br><span class="line">            CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                bookMapper.insertBatchSomeColumn(batch);</span><br><span class="line">            &#125;, dataProcessingExecutor);</span><br><span class="line"></span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有数据插入完成后退出阻塞</span></span><br><span class="line">        CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(String.valueOf(endTime-startTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用foreach的sql拼接插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：7024ms</span><br></pre></td></tr></table></figure><p><strong>使用mybatisPlus的saveBatch方法进行插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：7565ms</span><br></pre></td></tr></table></figure><h2 id="测试插入"><a href="#测试插入" class="headerlink" title="测试插入"></a>测试插入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookServiceImpl bookService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/insert&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertLargeData</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//主键设置为自增</span></span><br><span class="line">            <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">            book.setSid(<span class="string">&quot;s99&quot;</span>);</span><br><span class="line">            book.setBkname(<span class="string">&quot;sky&quot;</span>);</span><br><span class="line">            book.setPrice(<span class="number">99</span>);</span><br><span class="line">            book.setAuthor(<span class="string">&quot;sky&quot;</span>);</span><br><span class="line">            book.setSur(<span class="number">99</span>);</span><br><span class="line">            data.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">        bookService.concurrentBatchInsert(data,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大量数据插入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池的异步并发操作以及CompletableFuture的使用</title>
      <link href="/2025/04/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/04/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么定义线程池"><a href="#怎么定义线程池" class="headerlink" title="怎么定义线程池"></a>怎么定义线程池</h2><h3 id="实例化线程池作为bean注入到spring容器"><a href="#实例化线程池作为bean注入到spring容器" class="headerlink" title="实例化线程池作为bean注入到spring容器"></a>实例化线程池作为bean注入到spring容器</h3><p>通过ThreadPoolTaskExecutor创建一个线程池，自定义线程池参数，最后将该线程池作为bean注入到spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">dataProcessingExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * <span class="number">2</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">100</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">10000</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;DataProcessor-&quot;</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(name = &quot;exceptionDataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">exceptionDataProcessingExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * <span class="number">2</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">100</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">10000</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;ExceptionDataProcessor-&quot;</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="怎么开启线程池的异步处理功能"><a href="#怎么开启线程池的异步处理功能" class="headerlink" title="怎么开启线程池的异步处理功能"></a>怎么开启线程池的异步处理功能</h2><p>1.在application启动类上添加@EnableAsync注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;cn.bitoffer&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XTimerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(XTimerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在实例化线程池时添加@EnableAsync注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span><span class="comment">//运行方法异步执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.对需要异步处理的方法添加@Async(“schedulerPool”)注解，表示当前方法会放入线程池中异步处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line"><span class="comment">//@Async(&quot;dataProcessingExecutor&quot;)：这个注解表示 asyncHandleSlice 方法会在一个新的线程中异步执行。</span></span><br><span class="line"><span class="comment">//Spring会将这个方法提交给名为 dataProcessingExecutor 的线程池</span></span><br><span class="line"><span class="comment">//异步执行意味着该方法的调用不会阻塞当前线程，调用者可以继续执行其他操作。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncHandleSlice</span><span class="params">(Date date,<span class="type">int</span> bucketId)</span> &#123;</span><br><span class="line">    ...方法逻辑</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="怎么开启线程池并发处理任务的功能"><a href="#怎么开启线程池并发处理任务的功能" class="headerlink" title="怎么开启线程池并发处理任务的功能"></a>怎么开启线程池并发处理任务的功能</h2><p>想要使用线程池的并发处理任务功能，可以使用CompletableFuture提供的方法来方便地进行并发处理任务</p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>本文的CompletableFuture内容参考<a href="https://blog.csdn.net/javaeEEse/article/details/136186918">CompletableFuture使用详解（超详细）-CSDN博客</a></p><p><strong>CompletableFuture</strong>就是帮你处理这些任务之间的逻辑关系，编排好任务的执行方式后，任务会按照规划好的方式一步一步执行，不需要让业务线程去频繁的等待</p><p><strong>函数式编程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;U&gt;  <span class="comment">// 生产者，没有入参，有返回结果</span></span><br><span class="line">Consumer&lt;T&gt;  <span class="comment">// 消费者，有入参，但是没有返回结果</span></span><br><span class="line">Function&lt;T,U&gt;<span class="comment">// 函数，有入参，又有返回结果</span></span><br></pre></td></tr></table></figure><p><strong>先创建一个辅助类方便结果输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">smallTool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleepMillis</span><span class="params">(<span class="type">long</span> millis)</span>&#123;<span class="comment">//该方法主要是模拟线程的休眠</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(millis);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printTimeAndThread</span><span class="params">(String tag)</span>&#123;<span class="comment">//该方法主要是通过接受参数，再将调用该方法的该线程信息输出</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;\t|\t&quot;</span>)</span><br><span class="line">                .add(String.valueOf(System.currentTimeMillis()))</span><br><span class="line">                .add(String.valueOf(Thread.currentThread().getId()))</span><br><span class="line">                .add(Thread.currentThread().getName())</span><br><span class="line">                .add(tag)</span><br><span class="line">                .toString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="supplyAsync（无参，有返回值）"><a href="#supplyAsync（无参，有返回值）" class="headerlink" title="supplyAsync（无参，有返回值）"></a>supplyAsync（无参，有返回值）</h3><p>CompletableFuture中的supplyAsync方法，会开启一个新的线程，和主线程异步同时的执行任务；需要提供返回值，不提供参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白进入餐厅&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白点了菜+饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师打饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;菜和饭做好啦！&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor);<span class="comment">//指定使用的线程池</span></span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在刷视频&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s小白开吃&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><p>小白刷视频和厨师炒菜是同时开始进行的，先后顺序看情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745915054515|1|main|小白进入餐厅</span><br><span class="line">1745915054517|1|main|小白点了菜+饭</span><br><span class="line">1745915054521|1|main|小白在刷视频</span><br><span class="line">1745915054521|25|DataProcessor-1|厨师炒菜</span><br><span class="line">1745915054732|25|DataProcessor-1|厨师打饭</span><br><span class="line">1745915054841|1|main|菜和饭做好啦！小白开吃</span><br></pre></td></tr></table></figure><p>结果说明：开始的执行时间+线程id+线程名称+消息</p><h3 id="runAsync（无参，无返回值）"><a href="#runAsync（无参，无返回值）" class="headerlink" title="runAsync（无参，无返回值）"></a>runAsync（无参，无返回值）</h3><p>runAsync和supplyAsync使用方法相同，唯一的区别就是runAsync没有返回值，执行完代码逻辑后会直接退出</p><h3 id="thenApply（拼接代码）"><a href="#thenApply（拼接代码）" class="headerlink" title="thenApply（拼接代码）"></a>thenApply（拼接代码）</h3><p>thenApply()：把前面任务的执行结果，交给后面的Function，共用同一个线程，可以对前面的返回结果进行一系列处理后再返回</p><p>thenApply相当于把两块代码拼接到了一起，thenApply前面的代码和后面的代码是一起执行的，thenApply只作为拼接的作用，封装两段代码作为一个任务给一个线程去执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白吃完饭&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白准备结账&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1进行结账&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;500元&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenApply(money -&gt;&#123;<span class="comment">//这里共用同一个线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1开小票&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s&quot;</span>,money);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在打电话&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;小白付款%s&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745929093000|1|main|小白吃完饭</span><br><span class="line">1745929093000|1|main|小白准备结账</span><br><span class="line">1745929093002|25|DataProcessor-1|服务员1进行结账</span><br><span class="line">1745929093002|1|main|小白在打电话</span><br><span class="line">1745929093204|25|DataProcessor-1|服务员1开小票</span><br><span class="line">1745929093312|1|main|小白付款500元</span><br></pre></td></tr></table></figure><h3 id="thenApplyAsync"><a href="#thenApplyAsync" class="headerlink" title="thenApplyAsync"></a>thenApplyAsync</h3><p>该方法表示thenApplyAsync前面的代码块和后面的代码块是独立的两个异步任务，并不会像thenApply一样直接拼接，而是会开辟一个新线程来执行独立的任务或者复用原来的线程（虽然复用原来的线程是一个线程，但是异步任务是两个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白吃完饭&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白准备结账&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1进行结账&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;500元&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenApplyAsync(money -&gt;&#123;<span class="comment">//这里共用同一个线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1开小票&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s&quot;</span>,money);</span><br><span class="line">        &#125;,dataProcessingExecutor);</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在打电话&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;小白付款%s&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745928885934|1|main|小白吃完饭</span><br><span class="line">1745928885934|1|main|小白准备结账</span><br><span class="line">1745928885937|25|DataProcessor-1|服务员1进行结账</span><br><span class="line">1745928885937|1|main|小白在打电话</span><br><span class="line">1745928886145|26|DataProcessor-2|服务员1开小票</span><br><span class="line">1745928886255|1|main|小白付款500元</span><br></pre></td></tr></table></figure><h3 id="thenCompose（线程顺序执行）依赖"><a href="#thenCompose（线程顺序执行）依赖" class="headerlink" title="thenCompose（线程顺序执行）依赖"></a>thenCompose（线程顺序执行）依赖</h3><p>thenCompose()：当不同线程的任务执行有先后顺序时，并且依赖其返回值，则使用thenCompose；用来连接两个有依赖关系的任务，结果由第二个任务返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白进入餐厅&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白点了菜+饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;<span class="comment">//新开启一个厨师线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;番茄炒蛋&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenCompose(dish-&gt;CompletableFuture.supplyAsync(()-&gt;&#123;<span class="comment">//新开启一个服务员线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员打饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> dish+<span class="string">&quot;饭!&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor));</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在刷视频&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务和服务员打饭完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s小白开吃&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码中使用thenCompose，等待厨师线程完成任务后，有返回值后，下一个任务才会触发；此时”番茄炒蛋”返回值会存入dish中，然后开启一个服务员线程（函数式编程中的Function角色），接收厨师线程的返回值，然后进行一系列操作后，return其对应的返回值</p><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745917527573|1|main|小白进入餐厅</span><br><span class="line">1745917527573|1|main|小白点了菜+饭</span><br><span class="line">1745917527576|25|DataProcessor-1|厨师炒菜</span><br><span class="line">1745917527576|1|main|小白在刷视频</span><br><span class="line">1745917527776|26|DataProcessor-2|服务员打饭</span><br><span class="line">1745917527887|1|main|番茄炒蛋饭!小白开吃</span><br></pre></td></tr></table></figure><h3 id="thenCombine（线程同时执行）合并"><a href="#thenCombine（线程同时执行）合并" class="headerlink" title="thenCombine（线程同时执行）合并"></a>thenCombine（线程同时执行）合并</h3><p>该方法会使得不同线程异步同时执行，相当于将不同的线程执行进行合并，并且将线程的返回值进行结合返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白进入餐厅&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白点了菜+饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;番茄炒蛋&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenCombine(CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员蒸饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;米饭!&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor),(dish,rice)-&gt;&#123;<span class="comment">//将厨师线程和服务员线程的参数接受，然后返回结果</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员打饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s+%s&quot;</span>,dish,rice);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在刷视频&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s小白开吃&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1745919339096|1|main|小白进入餐厅</span><br><span class="line">1745919339096|1|main|小白点了菜+饭</span><br><span class="line">1745919339099|25|DataProcessor-1|厨师炒菜</span><br><span class="line">1745919339099|26|DataProcessor-2|服务员蒸饭</span><br><span class="line">1745919339100|1|main|小白在刷视频</span><br><span class="line">1745919339412|26|DataProcessor-2|服务员打饭</span><br><span class="line">1745919339522|1|main|番茄炒蛋+米饭!小白开吃</span><br></pre></td></tr></table></figure><h3 id="exceptionally"><a href="#exceptionally" class="headerlink" title="exceptionally"></a>exceptionally</h3><p>该方法会在supplyAsync执行时，如果执行期间抛出异常，则会直接进入到exceptionally块中，进行对异常处理后返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白吃完饭&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白准备结账&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1进行结账&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;小白跑路了！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;500元&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).exceptionally(e-&gt;&#123;</span><br><span class="line">           smallTool.printTimeAndThread(e.getMessage());</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;工作人员报警&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s,小白被抓了&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1745922097054|1|main|小白吃完饭</span><br><span class="line">1745922097054|1|main|小白准备结账</span><br><span class="line">1745922097057|25|DataProcessor-1|服务员1进行结账</span><br><span class="line">1745922097057|1|main|java.lang.RuntimeException: 小白跑路了！</span><br><span class="line">1745922097057|1|main|工作人员报警,小白被抓了</span><br></pre></td></tr></table></figure><h3 id="allOf"><a href="#allOf" class="headerlink" title="allOf"></a>allOf</h3><p>该方法会在所有的CompletableFuture线程异步执行完任务后，主线程才会进行后续操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt;futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//此处模拟10个线程异步并发执行的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            CompletableFuture&lt;Void&gt;future = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务&quot;</span>+ finalI +<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,dataProcessingExecutor);</span><br><span class="line">            <span class="comment">//将CompletableFuture添加进该list中，只有当list中所有的CompletableFuture执行完任务后allOf才放行</span></span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//allOf方法为主线程会等待所有的CompletableFuture开启的线程执行完任务后，才会进行后续执行</span></span><br><span class="line">        CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务执行完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">任务3完成</span><br><span class="line">任务2完成</span><br><span class="line">任务1完成</span><br><span class="line">任务7完成</span><br><span class="line">任务4完成</span><br><span class="line">任务0完成</span><br><span class="line">任务9完成</span><br><span class="line">任务6完成</span><br><span class="line">任务5完成</span><br><span class="line">任务8完成</span><br><span class="line">所有任务执行完成！</span><br></pre></td></tr></table></figure><h3 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf"></a>anyOf</h3><p>futures中如果有线程已经提前执行完了，那么anyOf就会放行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt;futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//此处模拟10个线程异步并发执行的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            CompletableFuture&lt;Void&gt;future = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务&quot;</span>+ finalI +<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,dataProcessingExecutor);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture.anyOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">        System.out.println(<span class="string">&quot;已有任务执行完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">任务0完成</span><br><span class="line">任务7完成</span><br><span class="line">任务1完成</span><br><span class="line">已有任务执行完成！</span><br><span class="line">任务4完成</span><br><span class="line">任务8完成</span><br><span class="line">任务9完成</span><br><span class="line">任务2完成</span><br><span class="line">任务5完成</span><br><span class="line">任务3完成</span><br><span class="line">任务6完成</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stream流的入门和使用</title>
      <link href="/2025/04/27/stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/04/27/stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="stream流的概念"><a href="#stream流的概念" class="headerlink" title="stream流的概念"></a>stream流的概念</h1><p>stream流可以看做一条流水线，先将数据读入stream流，在stream流上可以对数据进行一系列处理</p><h1 id="stream流的使用"><a href="#stream流的使用" class="headerlink" title="stream流的使用"></a>stream流的使用</h1><p>stream流可以对单列集合，双列集合，数组，零散数据进行一系列处理，过滤，收集，最后得到想要的结果</p><h2 id="单列集合使用stream流（list、set）"><a href="#单列集合使用stream流（list、set）" class="headerlink" title="单列集合使用stream流（list、set）"></a>单列集合使用stream流（list、set）</h2><p>单列集合通过Collections中的方法获取stream流</p><p>使用stream流的forEach方法来遍历list集合，并且顺序打印他</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //获取一条流水线,将该list集合的数据放到stream流水线上（stream流的匿名内部类的用法）</span></span><br><span class="line"><span class="comment">        Stream&lt;String&gt; stream = list.stream();</span></span><br><span class="line"><span class="comment">        stream.forEach(new Consumer&lt;String&gt;() &#123;//使用forEach来遍历list集合</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void accept(String s)&#123;//这里的s表示list集合中的一条数据</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以使用stream的链式调用（lambda）简化操作，这里的s代表list集合中的一条数据</span></span><br><span class="line">        <span class="comment">//s代表上面的匿名内部类的形参，-&gt;后面的操作是该形参的操作方法</span></span><br><span class="line">        list.stream().forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双列集合使用stream流（map）"><a href="#双列集合使用stream流（map）" class="headerlink" title="双列集合使用stream流（map）"></a>双列集合使用stream流（map）</h2><p>双列集合不能直接使用stream流，需要map先获取到key或entryKey后，才可以获取到stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;aaa&quot;</span>,<span class="number">111</span>);</span><br><span class="line">        map.put(<span class="string">&quot;bbb&quot;</span>,<span class="number">222</span>);</span><br><span class="line">        map.put(<span class="string">&quot;ccc&quot;</span>,<span class="number">33</span>);</span><br><span class="line">        map.put(<span class="string">&quot;ddd&quot;</span>,<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//map不能直接获取stream流，需要进行中转</span></span><br><span class="line">        <span class="comment">//1.map可以先通过获取键集合后，之后使用stream流</span></span><br><span class="line">        map.keySet().stream().forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.map也可以通过键值对集合后，使用stream流</span></span><br><span class="line">        map.entrySet().stream().forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">ccc</span><br><span class="line">bbb</span><br><span class="line">ddd</span><br><span class="line">=============</span><br><span class="line">aaa=111</span><br><span class="line">ccc=33</span><br><span class="line">bbb=222</span><br><span class="line">ddd=44</span><br></pre></td></tr></table></figure><h2 id="数组使用stream流"><a href="#数组使用stream流" class="headerlink" title="数组使用stream流"></a>数组使用stream流</h2><p>数组可以通过Arrays直接使用stream流，将数组名传入即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[]arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        String[]str = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//数组使用stream流可以直接通过Arrays方法，将数组名传入即可</span></span><br><span class="line">        Arrays.stream(arr).forEach(s-&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.stream(str).forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="零散的数据使用stream流"><a href="#零散的数据使用stream流" class="headerlink" title="零散的数据使用stream流"></a>零散的数据使用stream流</h2><p>零散的数据可以直接通过stream的of方法，进行使用stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).forEach(s-&gt; System.out.println(s));</span><br><span class="line">        Stream.of(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;cd&quot;</span>,<span class="string">&quot;ef&quot;</span>).forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stream流的中间方法"><a href="#stream流的中间方法" class="headerlink" title="stream流的中间方法"></a>stream流的中间方法</h1><p><strong>stream流的中间方法使用后会生成一个新的stream流，原stream流调用中间方法后就会关闭，不能使用了</strong></p><p><strong>中间方法只会修改stream流，传入stream流的原始数据不会变化</strong></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)----》过滤</span><br><span class="line">Stream&lt;T&gt; limit(long maxSize)----》获取前几个元素</span><br><span class="line">Stream&lt;T&gt; skip(long n)----》跳过前几个元素</span><br><span class="line">Stream&lt;T&gt; distinct()----》元素去重，依赖(hashCode和equals方法)</span><br><span class="line">static &lt;T&gt; Stream&lt;T&gt; concat(Stream a, Stream b)----》合并a和b两个流为一个流</span><br><span class="line">Stream&lt;R&gt; map(Function&lt;T ,R&gt; mapper)----》转换流中的数据类型</span><br></pre></td></tr></table></figure><h2 id="filter方法"><a href="#filter方法" class="headerlink" title="filter方法"></a>filter方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>,<span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张翠山&quot;</span>,<span class="string">&quot;张良&quot;</span>,<span class="string">&quot;王二麻子&quot;</span>,<span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //先使用stream流的匿名内部类的方式</span></span><br><span class="line"><span class="comment">        Stream&lt;String&gt; stream = list.stream();</span></span><br><span class="line"><span class="comment">        stream.filter(new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">                //如果为true则该条数据留下，如果startsWith判断该条记录是&#x27;张&#x27;开头的数据则返回true</span></span><br><span class="line"><span class="comment">                //如果为false则该条数据丢弃</span></span><br><span class="line"><span class="comment">                if(s.startsWith(&quot;张&quot;))return true;</span></span><br><span class="line"><span class="comment">                else return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).forEach(s-&gt; System.out.println(s));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用stream流的lambda表达式进行链式调用</span></span><br><span class="line">        <span class="comment">// s代表遍历过程中的一条记录，filter会判断当前记录是否是张开头，如果是则保留</span></span><br><span class="line">        list.stream().filter(s-&gt;s.startsWith(<span class="string">&quot;张&quot;</span>)).forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">张无忌</span><br><span class="line">张强</span><br><span class="line">张三丰</span><br><span class="line">张翠山</span><br><span class="line">张良</span><br></pre></td></tr></table></figure><h2 id="skip和limit方法"><a href="#skip和limit方法" class="headerlink" title="skip和limit方法"></a>skip和limit方法</h2><p>skip：跳过集合的前几个元素</p><p>limit：获取集合的前几个元素</p><p>这两个方法都是基于前一个中间方法操作后的新stream流的数据进行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>,<span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张翠山&quot;</span>,<span class="string">&quot;张良&quot;</span>,<span class="string">&quot;王二麻子&quot;</span>,<span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//skip表示跳过该集合的前3条记录，limit表示只显示该集合的4-7条记录</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .skip(<span class="number">3</span>)</span><br><span class="line">                .limit(<span class="number">4</span>)</span><br><span class="line">                .forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">张强</span><br><span class="line">张三丰</span><br><span class="line">张翠山</span><br><span class="line">张良</span><br></pre></td></tr></table></figure><h2 id="distinct和concat方法"><a href="#distinct和concat方法" class="headerlink" title="distinct和concat方法"></a>distinct和concat方法</h2><p>distinct：给集合中的元素去重，如果是list中存放的是自定义类，需要重写HashCode和equals方法才会生效</p><p>concat：Stream流的静态方法，用来合并stream流里的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list1,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list2,<span class="string">&quot;sky&quot;</span>,<span class="string">&quot;okk&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//distinct表示给集合去重，如果是list中存放的是自定义类，需要重写HashCode和equals方法才会生效</span></span><br><span class="line">        list1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(s-&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并两个stream流</span></span><br><span class="line">        Stream.concat(list1.stream(),list2.stream()).forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">张无忌</span><br><span class="line">周芷若</span><br><span class="line">谢广坤</span><br><span class="line">==============</span><br><span class="line">张无忌</span><br><span class="line">张无忌</span><br><span class="line">张无忌</span><br><span class="line">周芷若</span><br><span class="line">谢广坤</span><br><span class="line">sky</span><br><span class="line">okk</span><br></pre></td></tr></table></figure><h2 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h2><p>map方法用来给集合中的元素一系列处理（类型转换，修改数据）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌-15&quot;</span>,<span class="string">&quot;周芷若-14&quot;</span>,<span class="string">&quot;赵敏-13&quot;</span>,<span class="string">&quot;张强-20&quot;</span>,<span class="string">&quot;张三丰-100&quot;</span>,<span class="string">&quot;张翠山-40&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当想要对list中的数据进行类型转换时，使用stream流中的map方法（匿名内部类形式）</span></span><br><span class="line">        list.stream().map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;<span class="comment">//需要获取String字符串中的数字</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="comment">//s表示遍历集合过程中的一条记录</span></span><br><span class="line">                <span class="comment">//先进行分割字符串，再提取数字，最后类型转换返回age</span></span><br><span class="line">                String[] strings = s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strings[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">                <span class="keyword">return</span> age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).forEach(s-&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用map方法的lambda形式</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .map(s-&gt;Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream的终结方法"><a href="#Stream的终结方法" class="headerlink" title="Stream的终结方法"></a>Stream的终结方法</h1><p><strong>终结方法：当stream流执行完终结方法后就会退出stream流，然后返回</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void forEach(Consumer action)----&gt;遍历</span><br><span class="line">long count()----&gt;统计</span><br><span class="line">toArray()----&gt;收集流中的数据，放到数组中</span><br><span class="line">collect(Collector collector)----&gt;收集流中的数据，放到集合中</span><br></pre></td></tr></table></figure><h2 id="forEach和count方法"><a href="#forEach和count方法" class="headerlink" title="forEach和count方法"></a>forEach和count方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌-15&quot;</span>,<span class="string">&quot;周芷若-14&quot;</span>,<span class="string">&quot;赵敏-13&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//forEach用来遍历集合</span></span><br><span class="line">        list.stream().forEach(s-&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//count用来统计集合个数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toArray方法"><a href="#toArray方法" class="headerlink" title="toArray方法"></a>toArray方法</h2><p>stream流的toArray方法会先创建一个数组，然后stream流将list中的数据一个个赋值到该数组中，最后返回该数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌-15&quot;</span>,<span class="string">&quot;周芷若-14&quot;</span>,<span class="string">&quot;赵敏-13&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//toArray方法用来将集合变为数组</span></span><br><span class="line">        <span class="comment">//1.将集合转换为默认Object类型的数组</span></span><br><span class="line">        Object[] arr1 = list.stream().toArray();</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1使用匿名内部类的方式，将集合转换为指定类型的数组</span></span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        String[] arr2 = stream.toArray(<span class="keyword">new</span> <span class="title class_">IntFunction</span>&lt;String[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String[] apply(<span class="type">int</span> value) &#123;<span class="comment">//value表示数组长度</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[value];<span class="comment">//这里面填写数组长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2使用lambda表达式，将集合转换为指定类型的数组</span></span><br><span class="line">        <span class="comment">//lambda表达式省略return，会将new String[value]该值直接返回</span></span><br><span class="line">        String[] arr3 = list.stream().toArray(value -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[value]);</span><br><span class="line">        System.out.println(Arrays.toString(arr3));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[张无忌-<span class="number">15</span>, 周芷若-<span class="number">14</span>, 赵敏-<span class="number">13</span>]</span><br><span class="line">[张无忌-<span class="number">15</span>, 周芷若-<span class="number">14</span>, 赵敏-<span class="number">13</span>]</span><br><span class="line">[张无忌-<span class="number">15</span>, 周芷若-<span class="number">14</span>, 赵敏-<span class="number">13</span>]</span><br></pre></td></tr></table></figure><h2 id="collect方法-将数据转换为List-Set-Map集合"><a href="#collect方法-将数据转换为List-Set-Map集合" class="headerlink" title="collect方法(将数据转换为List,Set,Map集合)"></a>collect方法(将数据转换为List,Set,Map集合)</h2><p>stream流的collect方法可以将数据进行一系列处理后，转换为不同的集合</p><p><strong>将数据收集到list和set中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌-男-15&quot;</span>,<span class="string">&quot;张无忌-男-15&quot;</span>,<span class="string">&quot;周芷若-女-14&quot;</span>,<span class="string">&quot;赵敏-女-13&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收集所有为男性的信息到list中</span></span><br><span class="line">        List&lt;String&gt; list1 = list.stream()</span><br><span class="line">                .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收集所有为男性的信息到set中,收集到set中时会自动去重</span></span><br><span class="line">        Set&lt;String&gt; set = list.stream()</span><br><span class="line">                .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[张无忌-男-<span class="number">15</span>, 张无忌-男-<span class="number">15</span>]</span><br><span class="line">[张无忌-男-<span class="number">15</span>]</span><br></pre></td></tr></table></figure><p><strong>将数据收集到map中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌-男-15&quot;</span>,<span class="string">&quot;sky-男-16&quot;</span>,<span class="string">&quot;周芷若-女-14&quot;</span>,<span class="string">&quot;赵敏-女-13&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.使用匿名内部类，收集数据到map中</span></span><br><span class="line">        <span class="comment">//将数据收集到map中，需要定义键值对的规则，如果存入map中的key重复时会抛出异常(例如当有两个张无忌存在时，java.lang.IllegalStateException: Duplicate key 15)</span></span><br><span class="line">        <span class="comment">//此处将list中的姓名作为key，年龄作为value</span></span><br><span class="line">        Map&lt;String, Integer&gt; map1 = list.stream()</span><br><span class="line">                .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .collect(Collectors.toMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, String&gt;() &#123;<span class="comment">//第一部分是键的规则</span></span><br><span class="line">                    <span class="comment">//键的定义规则：在new Function&lt;String, String&gt;中第一个String指的是apply方法的形参（即集合中的数据）</span></span><br><span class="line">                    <span class="comment">// 第二个String表示apply方法的返回值，将该返回值作为map的key</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;<span class="comment">//第二部分是值的规则</span></span><br><span class="line">                    <span class="comment">//值的定义规则和键的相同，new Function&lt;String, Integer&gt;中第一个参数String为形参（list中的数据）</span></span><br><span class="line">                    <span class="comment">//第二个参数Integer则表示apply方法的返回值，将该返回值作为map的value</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;));</span><br><span class="line">        System.out.println(map1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使用lambda表达式，将数据收集到map中</span></span><br><span class="line">        Map&lt;String, Integer&gt; map2 = list.stream()</span><br><span class="line">                .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .collect(Collectors.toMap(s1-&gt;s1.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>],s2-&gt;Integer.parseInt(s2.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>])));</span><br><span class="line">        System.out.println(map2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;sky=<span class="number">16</span>, 张无忌=<span class="number">15</span>&#125;</span><br><span class="line">===========</span><br><span class="line">&#123;sky=<span class="number">16</span>, 张无忌=<span class="number">15</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stream流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术的那点事</title>
      <link href="/2025/04/16/%E4%B8%9A%E5%8A%A1%E7%A7%AF%E7%B4%AF/"/>
      <url>/2025/04/16/%E4%B8%9A%E5%8A%A1%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="技术积累"><a href="#技术积累" class="headerlink" title="技术积累"></a>技术积累</h2><h3 id="全局异常捕获和状态码返回"><a href="#全局异常捕获和状态码返回" class="headerlink" title="全局异常捕获和状态码返回"></a>全局异常捕获和状态码返回</h3><p><strong>怎么定义全局异常？</strong> </p><p>想要使用全局异常首先需要定义一个<code>GlobalExceptionHandler.java</code>类和自定义异常类<code>DatabaseSetDataException</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseSetDataException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DatabaseSetDataException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(DatabaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Wrapper <span class="title function_">handleDataAccessException</span><span class="params">(DatabaseSetDataException ex)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;数据库操作失败: &quot;</span>+ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> Wrapper.ERROR_BUILDER <span class="comment">//在这里调用wrapper的Eror_builder会将Wrapper里原先设置的code(-1)进行覆盖，不会产生两个code</span></span><br><span class="line">                .code(ex.getCode())</span><br><span class="line">                .message(<span class="string">&quot;操作失败&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Wrapper是什么？</strong></p><p>Wrapper是状态码的统一返回规范类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span><span class="comment">//启用builder构建者模式</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wrapper</span> <span class="keyword">implements</span> <span class="title class_">ResponseRestful</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功响应 Builder</span></span><br><span class="line">    <span class="comment">//如果使用SUCCESS的话，会先调用suc_builder进行拼接code和message</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">WrapperBuilder</span> <span class="variable">SUCCESS_BUILDER</span> <span class="operator">=</span> Wrapper.builder().code(<span class="number">0</span>).data(<span class="number">0</span>).message(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Wrapper</span> <span class="variable">SUCCESS</span> <span class="operator">=</span> SUCCESS_BUILDER.build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用错误 Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">WrapperBuilder</span> <span class="variable">ERROR_BUILDER</span> <span class="operator">=</span> Wrapper.builder().code(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Wrapper</span> <span class="variable">ERROR</span> <span class="operator">=</span> ERROR_BUILDER.message(<span class="string">&quot;ERROR&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会话错误 Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">WrapperBuilder</span> <span class="variable">SESSION_ERROR_BUILDER</span> <span class="operator">=</span> Wrapper.builder().code(<span class="number">510</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Builder构建者模式的使用</strong></p><p>拿上面的Wrapper举例，里面的<code>WrapperBuilder SUCCESS_BUILDER = Wrapper.builder().code(0).data(0).message(&quot;OK&quot;);</code>相当于构建了一个WrapperBuilder对象；只有当<code>Wrapper SUCCESS = SUCCESS_BUILDER.build();</code>使用了builde（）方法，才算是对象构建完成。可以理解为new Wrapper（），然后set属性</p><p><strong>怎么抛出异常，然后被全局异常捕获</strong></p><p>此处是在service层抛出异常，然后被全局异常处理器捕获</p><p>在可能出现异常的地方进行try-catch，catch的异常就是自定义的数据库异常，捕获异常后可以进行对应的异常抛出和处理；当抛出DatabaseSetDataException后会被全局异常处理器捕获到，最后返回对应的错误码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YyAppointmentInfoServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;YyAppointmentInfoMapper, YyAppointmentInfo&gt; <span class="keyword">implements</span> <span class="title class_">IYyAppointmentInfoService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    YyAppointmentInfoMapper yyAppointmentInfoMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataExceptionHandImpl dataExceptionHand;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAppointInfo</span><span class="params">(YyAppointmentInfo appointmentInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            appointmentInfo.setRksj(LocalDateTime.now());</span><br><span class="line">            yyAppointmentInfoMapper.insert(appointmentInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            <span class="comment">//将存入数据异常的对象存入，传入对应的type，异常信息</span></span><br><span class="line">            dataExceptionHand.handleInsertException(appointmentInfo,<span class="number">0</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode更新博客要点</title>
      <link href="/2025/04/15/vscode%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%A6%81%E7%82%B9/"/>
      <url>/2025/04/15/vscode%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo博客更新"><a href="#hexo博客更新" class="headerlink" title="hexo博客更新"></a>hexo博客更新</h2><p>需要新增一篇博客时直接在blog文件夹下hexo new “文件名”</p><hr><h2 id="推送信息"><a href="#推送信息" class="headerlink" title="推送信息"></a>推送信息</h2><p>当在vscode更新时需要每次从本地提交到远程，再重新启动才会生效<br>修改完内容后：</p><ol><li>git add -A(添加到缓冲区)</li><li>git commit -m “此次修改的描述信息”</li><li>git push(推送到远程;如果出现fatal: unable to access ‘<a href="https://github.com/legend578/legend578.github.io.git/">https://github.com/legend578/legend578.github.io.git/</a>‘: Failed to connect to 127.0.0.1 port 7897 after 2107 ms: Could not connect to server则进行开启clash代理)<br>hexo d（使得网站重新生效）</li></ol><hr><h2 id="怎么将博客放入到标签和分类中"><a href="#怎么将博客放入到标签和分类中" class="headerlink" title="怎么将博客放入到标签和分类中"></a>怎么将博客放入到标签和分类中</h2><p>在每篇博客的顶部，进行设置categories和tags，想要将该博客归属到哪，就在下面编写对应文字<br><img src="/2025/04/15/vscode%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%A6%81%E7%82%B9/vscode1.png" width="auto" height="auto"></p><h2 id="怎么在博客中插入图片"><a href="#怎么在博客中插入图片" class="headerlink" title="怎么在博客中插入图片"></a>怎么在博客中插入图片</h2><p>使用<img src="/2025/04/15/vscode%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%A6%81%E7%82%B9/vscode1.png" width="auto" height="auto">，使用img标签即可，src填写图片路径，可以是外部图片，也可以是本机图片</p>]]></content>
      
      
      <categories>
          
          <category> 博客相关修改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客怎么更新 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/background.css"/>
      <url>/css/background.css</url>
      
        <content type="html"><![CDATA[#web_bg {  /* webkit内核 5.1 - 6.0 */  background: -webkit-linear-gradient(left, red, blue);  /* Opera 11.1 - 12.0 */  background: -o-linear-gradient(right, red, blue);  /* Firefox 3.6 - 15 */  background: -moz-linear-gradient(right, red, blue);  /* 标准的语法 */  background: linear-gradient(to right, red, blue);}/* 文章页背景 */.layout_post>#post {    /* 以下代表白色透明度为0.3 */    background: rgba(255,255,255,.3);}/* 所有背景（包括首页卡片、文章页、页面页等） */#aside_content .card-widget, #recent-posts>.recent-post-item, .layout_page>div:first-child:not(.recent-posts), .layout_post>#page, .layout_post>#post, .read-mode .layout_post>#post{    /* 以下代表白色透明度为0.3 */    background: rgba(255,255,255,.3);}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
