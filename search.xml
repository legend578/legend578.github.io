<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>空指针异常的原因和解决</title>
      <link href="/2025/05/30/%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
      <url>/2025/05/30/%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>起因是在将数据库的数据查询出来进行操作时，抛出了空指针异常</p><p>一开始为了防止操作空值，从数据库中查询到encData数据进行操作前判空</p><p>结果发现在判空的时候就已经空指针异常了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(encData))&#123;</span><br><span class="line">    log.error(encStr+<span class="string">&quot;解密的数据为空！&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据库查询的数据分为两种空：null和空白值</p><p>使用空白值进行操作是不会空指针异常的，但是使用null来调用isEmpty则会抛出空指针异常</p><p><strong>解决方法：</strong></p><p>使用org.apache.commons.lang3.StringUtils工具类进行判空即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(encData))&#123;</span><br><span class="line">    log.error(encStr+<span class="string">&quot;解密的数据为空！&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="什么情况会导致空指针异常？"><a href="#什么情况会导致空指针异常？" class="headerlink" title="什么情况会导致空指针异常？"></a>什么情况会导致空指针异常？</h1><h2 id="使用null调用方法"><a href="#使用null调用方法" class="headerlink" title="使用null调用方法"></a>使用null调用方法</h2><p>将字符串置为“”，这不是一个null值，是可以正常操作的</p><p>将字符串置为null，将该空值调用方法时都会抛出空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">nul</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(str.length());<span class="comment">//正常输出0</span></span><br><span class="line">System.out.println(nul.length());<span class="comment">//抛出空指针异常</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">nul</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(str.isEmpty());<span class="comment">//输出true</span></span><br><span class="line">System.out.println(nul.isEmpty());<span class="comment">//抛出空指针异常</span></span><br></pre></td></tr></table></figure><p>可以从上面例子看出：只要是以 null值.方法（）这种方式调用方法都会抛出空指针异常</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>使用org.apache.commons.lang3.StringUtils工具类进行判空后再进行操作</p><p>该工具类所属依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于null值特殊处理：抛出异常信息或抛出错误日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">nul</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(nul))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;this is null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(nul.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况也会被判断为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String nul = &quot;&quot;;</span><br><span class="line">if(StringUtils.isEmpty(nul))&#123;</span><br><span class="line">System.out.println(&quot;this is null&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">System.out.println(nul.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cookie,Session,Jwt之间的区别和使用</title>
      <link href="/2025/05/19/Cookie-Session-Jwt%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/05/19/Cookie-Session-Jwt%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要Cookie和Session"><a href="#为什么需要Cookie和Session" class="headerlink" title="为什么需要Cookie和Session"></a>为什么需要Cookie和Session</h1><p>原因：由于HTTP是无状态的，HTTP的每个请求都是独立的，服务器不会保存客户端之前的请求和会话状态，所以单单依靠HTTP，是无法实现用户登录后，访问其他页面也是使用之前的登录状态，而是会跳转到重新登录页面。</p><p>所以需要Cookie和Session来实现用户登录状态的保存！</p><h2 id="Cookie和Session的使用"><a href="#Cookie和Session的使用" class="headerlink" title="Cookie和Session的使用"></a>Cookie和Session的使用</h2><p>1.用户登录时将用户名和密码传递给服务端进行校验身份</p><p>2.校验身份成功后，服务端会创建一个session对象用来存储用户信息（session保存在内存中），并返回一个session_id给客户端</p><p>3.客户端将session_id存入cookie中，后续客户端每次进行访问该服务端进行携带该session_id即可</p><p>4.服务端接受到session_id后，根据该id去查询之前保存的session信息</p><img src="C:\Users\彭思凯\AppData\Roaming\Typora\typora-user-images\image-20250519175704245.png" alt="image-20250519175704245" style="zoom:80%;" /><h2 id="使用Cookie和Session保存用户状态的缺点"><a href="#使用Cookie和Session保存用户状态的缺点" class="headerlink" title="使用Cookie和Session保存用户状态的缺点"></a>使用Cookie和Session保存用户状态的缺点</h2><p>session是保存在服务器的内存中的。当服务端部署的机器是集群的情况，那么这些机器都需要保存相同的session信息，如果有一台机器没有保存到该session信息，那么进行负载均衡访问该机器时，就会跳转到登录页面重新登录</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>1.使用MySQL和Redis来保存用户信息</strong></p><p>由于session保存在内存中，所以服务端是集群的情况时，需要全都同步该session信息。所以可以使用数据库保存session_id，当用户传递一个session_id过来时，服务端可以去数据库查询是否存在该session_id来判断用户的登录状态。缺点：存在单点故障（如果数据库宕机，则保存的信息就访问不到或者丢失，如果部署数据库集群又会过于麻烦）</p><p><strong>2.使用JWT来进行无状态登录</strong></p><p>JWT工作流程：</p><p>1.用户登录时将用户名和密码传递给服务端，服务端校验用户身份成功后会生成JWT返回给客户端</p><p>2.客户端将该JWT保存在本地，之后每次访问服务端时都在请求头中携带该JWT</p><p>3.服务端接受到客户端请求后，从请求头中提取出JWT内容</p><p>4.验证JWT签名：</p><ul><li>服务端使用预存的密钥（如 HMAC 的共享密钥或 RSA 的公钥），重新计算 JWT 的签名。</li><li>对比计算的签名与 JWT 中的第三段（签名段）是否一致</li></ul><p><strong>客户端保存的JWT格式(Authorization)：Header.Payload.Signature</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /restful/products/1 HTTP/1.1</span><br><span class="line">Host: icyfenix.cn</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Authorization: Bearer eyJhbGciOiJXVCJ9.eyJ1c2VyXpeCJ9.539WMzbAn8bheflL8</span><br></pre></td></tr></table></figure><img src="C:\Users\彭思凯\AppData\Roaming\Typora\typora-user-images\image-20250519180502861.png" alt="image-20250519180502861"  /><h2 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h2><p>存储位置：Cookie存放在本地浏览器中，session存储在服务端中</p><p>存储大小：Cookie存放在浏览器中，大小是有限制的，不能超过4K；而session存储大小没有限制</p><p>安全性：因为Cookie存放在浏览器中，安全性较低；session存放在服务端中，安全性高一点</p><p>有效时间：Cookie有效时间比session长</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用FastJson来进行JSON和Java数据互相转换</title>
      <link href="/2025/05/16/JSON%E5%92%8CJava%E6%95%B0%E6%8D%AE%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"/>
      <url>/2025/05/16/JSON%E5%92%8CJava%E6%95%B0%E6%8D%AE%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>使用alibaba的fastjson来进行转换</p><p>需要先导入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="解析JSON数据"><a href="#解析JSON数据" class="headerlink" title="解析JSON数据"></a>解析JSON数据</h1><p>拿以下的json数据进行举例，一层层解析json对象和json数组，最终得到picUrl的值</p><p>解析过程：获取到该字符串&#x3D;》解析该字符串为json对象&#x3D;》解析该json对象中的json数组list&#x3D;》解析list数组中的元素（json对象）&#x3D;》通过解析出来的json对象，再进行解析faces的json数组&#x3D;》解析faces中的元素（json对象）&#x3D;》通过解析出来的json对象获取到picUrl的值</p><p>{}表示这是一个json对象，[]表示这是一个json数组</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="comment">//json对象</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SUCCESS&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="comment">//json对象</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pageSize&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pageNo&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//json数组</span></span><br><span class="line">      <span class="punctuation">&#123;</span><span class="comment">//json对象</span></span><br><span class="line">        <span class="attr">&quot;humanId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7d29167378d_08866a80c&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;faces&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//json数组</span></span><br><span class="line">          <span class="punctuation">&#123;</span><span class="comment">//json对象</span></span><br><span class="line">            <span class="attr">&quot;photoId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;80270rfyh29hf299u9&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;photocUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://127.0.0.1:8080/pic?4dda-16e4611i4c33pb&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;bornTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2011-06-10&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;residenceCountyCode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;330602&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>1.首先调用接口获取这么一串字符串</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">params.<span class="title function_">put</span>(<span class="string">&quot;sfz&quot;</span>, data.<span class="title function_">get</span>(idNumberName));</span><br><span class="line">params.<span class="title function_">put</span>(<span class="string">&quot;type&quot;</span>, <span class="keyword">type</span>);</span><br><span class="line"><span class="title class_">String</span> res = easyOkClient.<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:8891/test&quot;</span>, params);</span><br></pre></td></tr></table></figure><p><strong>2.校验res是否合法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(res)) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;接口返回结果为空&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.将res字符串解析为<strong><strong>json</strong></strong>对象(resObject )</strong></p><p>json数据最外层的{}表示这是一个json对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JSONObject</span> <span class="variable">resObject</span> <span class="operator">=</span> JSONObject.parseObject(res);</span><br></pre></td></tr></table></figure><p><strong>4.解析<strong><strong>json</strong></strong>对象(resObject )中的字符串</strong></p><p>因为前面已经获取到了最外层的json对象，所以可以通过该json对象使用getString方法来获取json对象里的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;code&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="string">&quot;0&quot;</span>.equals(code)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">    log.warn(<span class="string">&quot;接口调用失败，code=&#123;&#125;, message=&#123;&#125;&quot;</span>, code, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.解析<strong><strong>json</strong></strong>对象(resObject )里的json对象(dataObj)</strong></p><p>因为在在外层的json对象里的data存在{}，说明data也是一个json对象，通过getJSONObject来获取json对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span><span class="built_in">Object</span> dataObj = jsonObject.<span class="title function_">getJSONObject</span>(<span class="string">&quot;data&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (dataObj == <span class="literal">null</span>) &#123;</span><br><span class="line">    log.<span class="title function_">warn</span>(<span class="string">&quot;data 字段为空&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.解析<strong><strong>json</strong></strong>对象（dataObj）里的json数组（faces）</strong></p><p>在data的json对象里的faces是一个json数组，所以通过getJSONArray来获取json对象中的json数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span><span class="built_in">Array</span> listArray = dataObj.<span class="title function_">getJSONArray</span>(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (listArray == <span class="literal">null</span> || listArray.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    log.<span class="title function_">warn</span>(<span class="string">&quot;list 数组为空&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.获取<strong><strong>json</strong></strong>数组（listArray）中的元素（json对象&#x2F;String字符串）</strong></p><p>以下情况为json数组中存在json对象（因为在示例中，faces:[{},{}]，说明faces数组里存放的是json对象；如果faces:[“”,””]这样的情况，那么直接通过faces.getString就可以获取数组中的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; listArray.<span class="title function_">size</span>(); i++) &#123;</span><br><span class="line">    <span class="title class_">JSON</span><span class="built_in">Object</span> person = listArray.<span class="title function_">getJSONObject</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">JSON</span><span class="built_in">Array</span> faces = person.<span class="title function_">getJSONArray</span>(<span class="string">&quot;faces&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (faces != <span class="literal">null</span> &amp;&amp; !faces.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; faces.<span class="title function_">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">//先获取faces数组中的json对象</span></span><br><span class="line">            <span class="title class_">JSON</span><span class="built_in">Object</span> face = faces.<span class="title function_">getJSONObject</span>(j);</span><br><span class="line">            <span class="comment">//通过getString来获取json对象中的字符串值</span></span><br><span class="line">            <span class="title class_">String</span> picUrl = face.<span class="title function_">getString</span>(<span class="string">&quot;picUrl&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="title class_">StringUtils</span>.<span class="title function_">isEmpty</span>(picUrl)) &#123;</span><br><span class="line">                log.<span class="title function_">info</span>(<span class="string">&quot;提取到的 picUrl：&#123;&#125;&quot;</span>, picUrl);</span><br><span class="line">                <span class="keyword">return</span> picUrl; <span class="comment">// 返回第一个有效 url</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java和JSON数据互转"><a href="#Java和JSON数据互转" class="headerlink" title="Java和JSON数据互转"></a>Java和JSON数据互转</h1><h2 id="Java对象转为JSON字符串"><a href="#Java对象转为JSON字符串" class="headerlink" title="Java对象转为JSON字符串"></a>Java对象转为JSON字符串</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.<span class="property">alibaba</span>.<span class="property">fastjson</span>.<span class="property">JSON</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个Java对象</span></span><br><span class="line">        <span class="title class_">User</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.<span class="title function_">setId</span>(<span class="number">1</span>);</span><br><span class="line">        user.<span class="title function_">setName</span>(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">        user.<span class="title function_">setEmail</span>(<span class="string">&quot;john.doe@example.com&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 使用Fastjson将Java对象转换为JSON字符串</span></span><br><span class="line">        <span class="title class_">String</span> jsonString = <span class="title class_">JSON</span>.<span class="title function_">toJSONString</span>(user);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(jsonString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> int id;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> email;</span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON字符串转为Java对象"><a href="#JSON字符串转为Java对象" class="headerlink" title="JSON字符串转为Java对象"></a>JSON字符串转为Java对象</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.<span class="property">alibaba</span>.<span class="property">fastjson</span>.<span class="property">JSON</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">// JSON字符串</span></span><br><span class="line">        <span class="title class_">String</span> jsonString = <span class="string">&quot;&#123;\&quot;email\&quot;:\&quot;john.doe@example.com\&quot;,\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;John Doe\&quot;&#125;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 使用Fastjson将JSON字符串转换为Java对象</span></span><br><span class="line">        <span class="title class_">User</span> user = <span class="title class_">JSON</span>.<span class="title function_">parseObject</span>(jsonString, <span class="title class_">User</span>.<span class="property">class</span>);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(user.<span class="title function_">getName</span>()); <span class="comment">// 输出 John Doe</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> int id;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> email;</span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java对象和JSONObject相互转换"><a href="#Java对象和JSONObject相互转换" class="headerlink" title="Java对象和JSONObject相互转换"></a>Java对象和JSONObject相互转换</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.<span class="property">alibaba</span>.<span class="property">fastjson</span>.<span class="property">JSON</span>;</span><br><span class="line"><span class="keyword">import</span> com.<span class="property">alibaba</span>.<span class="property">fastjson</span>.<span class="property">JSONObject</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个Java对象</span></span><br><span class="line">        <span class="title class_">User</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.<span class="title function_">setId</span>(<span class="number">1</span>);</span><br><span class="line">        user.<span class="title function_">setName</span>(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">        user.<span class="title function_">setEmail</span>(<span class="string">&quot;john.doe@example.com&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Java对象转JSONObject</span></span><br><span class="line">        <span class="title class_">JSON</span><span class="built_in">Object</span> jsonObject = (<span class="title class_">JSON</span><span class="built_in">Object</span>) <span class="title class_">JSON</span>.<span class="title function_">toJSON</span>(user);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(jsonObject.<span class="title function_">getString</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// 输出 John Doe</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// JSONObject转Java对象</span></span><br><span class="line">        <span class="title class_">User</span> userFromJson = <span class="title class_">JSON</span>.<span class="title function_">toJavaObject</span>(jsonObject, <span class="title class_">User</span>.<span class="property">class</span>);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(userFromJson.<span class="title function_">getName</span>()); <span class="comment">// 输出 John Doe</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> int id;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> email;</span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大量数据批量存入的性能优化</title>
      <link href="/2025/04/29/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2025/04/29/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>当在数据量比较大需要插入时，进行逐条插入MySQL可能会速度很慢，所以这时有几种思路来进行优化</p><h2 id="1-使用mybatisPlus的saveBatch方法进行批量插入"><a href="#1-使用mybatisPlus的saveBatch方法进行批量插入" class="headerlink" title="1.使用mybatisPlus的saveBatch方法进行批量插入"></a>1.使用mybatisPlus的saveBatch方法进行批量插入</h2><p><strong>service调用</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookMapper, Book&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concurrentBatchInsert</span><span class="params">(List&lt;Book&gt; books, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据分片，需要引入hutool依赖，给books中的100w数据进行分片，每个list子集合1000条数据</span></span><br><span class="line">        List&lt;List&lt;Book&gt;&gt; batches = ListUtil.partition(books, batchSize);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Book&gt; batch : batches) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始批量插入数据&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.saveBatch(batch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;耗费时间：&quot;</span>+String.valueOf(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：34723ms</span><br></pre></td></tr></table></figure><h2 id="2-使用foreach进行sql拼接，来进行批量插入"><a href="#2-使用foreach进行sql拼接，来进行批量插入" class="headerlink" title="2.使用foreach进行sql拼接，来进行批量插入"></a>2.使用foreach进行sql拼接，来进行批量插入</h2><p><strong>service调用逻辑</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookMapper, Book&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concurrentBatchInsert</span><span class="params">(List&lt;Book&gt; books, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据分片，需要引入hutool依赖，给books中的10w数据进行分片，每个list子集合1000条数据</span></span><br><span class="line">        List&lt;List&lt;Book&gt;&gt; batches = ListUtil.partition(books, batchSize);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Book&gt; batch : batches) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始批量插入数据&quot;</span>);</span><br><span class="line">            bookMapper.insertBatchSomeColumn(batch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;耗费时间：&quot;</span>+String.valueOf(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapper接口层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Book&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertBatchSomeColumn</span><span class="params">(<span class="meta">@Param(&quot;batch&quot;)</span> List&lt;Book&gt; batch)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapper.xml</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.sky.work_test.mapper.BookMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">&quot;insertBatchSomeColumn&quot;</span>&gt;</span><br><span class="line">        INSERT INTO <span class="title function_">book</span> <span class="params">(bkname,sid,price,author,sur)</span></span><br><span class="line">        VALUES</span><br><span class="line">        &lt;foreach collection=<span class="string">&quot;batch&quot;</span> item=<span class="string">&quot;item&quot;</span> separator=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">            (#&#123;item.bkname&#125;, #&#123;item.sid&#125;,#&#123;item.price&#125;,#&#123;item.author&#125;,#&#123;item.sur&#125;)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：29760ms</span><br></pre></td></tr></table></figure><h2 id="3-在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务"><a href="#3-在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务" class="headerlink" title="3.在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务"></a>3.在数据量很大的时候可以考虑使用线程池来异步并发的执行插入任务</h2><p><strong>此处使用线程池异步并发来处理批量任务插入，插入方法可以是sql拼接或者mybatisPlus的saveBatch</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookMapper, Book&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor  dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span><span class="comment">//异步执行</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concurrentBatchInsert</span><span class="params">(List&lt;Book&gt; books, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">        <span class="comment">//创建list集合接受线程的返回值</span></span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据分片，需要引入hutool依赖，给books中的100w数据进行分片，每个list子集合存放1000条数据</span></span><br><span class="line">        List&lt;List&lt;Book&gt;&gt; batches = ListUtil.partition(books, batchSize);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Book&gt; batch : batches) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始批量插入数据&quot;</span>);</span><br><span class="line">            <span class="comment">//开启多个线程并行执行</span></span><br><span class="line">            CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                bookMapper.insertBatchSomeColumn(batch);</span><br><span class="line">            &#125;, dataProcessingExecutor);</span><br><span class="line"></span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有数据插入完成后退出阻塞</span></span><br><span class="line">        CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(String.valueOf(endTime-startTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用foreach的sql拼接插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：7024ms</span><br></pre></td></tr></table></figure><p><strong>使用mybatisPlus的saveBatch方法进行插入100w数据耗时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗费时间：7565ms</span><br></pre></td></tr></table></figure><h2 id="测试插入"><a href="#测试插入" class="headerlink" title="测试插入"></a>测试插入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookServiceImpl bookService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/insert&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertLargeData</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//主键设置为自增</span></span><br><span class="line">            <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">            book.setSid(<span class="string">&quot;s99&quot;</span>);</span><br><span class="line">            book.setBkname(<span class="string">&quot;sky&quot;</span>);</span><br><span class="line">            book.setPrice(<span class="number">99</span>);</span><br><span class="line">            book.setAuthor(<span class="string">&quot;sky&quot;</span>);</span><br><span class="line">            book.setSur(<span class="number">99</span>);</span><br><span class="line">            data.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">        bookService.concurrentBatchInsert(data,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大量数据插入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池的异步并发操作以及CompletableFuture的使用</title>
      <link href="/2025/04/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/04/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么定义线程池"><a href="#怎么定义线程池" class="headerlink" title="怎么定义线程池"></a>怎么定义线程池</h2><h3 id="实例化线程池作为bean注入到spring容器"><a href="#实例化线程池作为bean注入到spring容器" class="headerlink" title="实例化线程池作为bean注入到spring容器"></a>实例化线程池作为bean注入到spring容器</h3><p>通过ThreadPoolTaskExecutor创建一个线程池，自定义线程池参数，最后将该线程池作为bean注入到spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">dataProcessingExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * <span class="number">2</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">100</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">10000</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;DataProcessor-&quot;</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(name = &quot;exceptionDataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">exceptionDataProcessingExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * <span class="number">2</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">100</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">10000</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;ExceptionDataProcessor-&quot;</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="怎么开启线程池的异步处理功能"><a href="#怎么开启线程池的异步处理功能" class="headerlink" title="怎么开启线程池的异步处理功能"></a>怎么开启线程池的异步处理功能</h2><p>1.在application启动类上添加@EnableAsync注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;cn.bitoffer&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XTimerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(XTimerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在实例化线程池时添加@EnableAsync注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span><span class="comment">//运行方法异步执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.对需要异步处理的方法添加@Async(“schedulerPool”)注解，表示当前方法会放入线程池中异步处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line"><span class="comment">//@Async(&quot;dataProcessingExecutor&quot;)：这个注解表示 asyncHandleSlice 方法会在一个新的线程中异步执行。</span></span><br><span class="line"><span class="comment">//Spring会将这个方法提交给名为 dataProcessingExecutor 的线程池</span></span><br><span class="line"><span class="comment">//异步执行意味着该方法的调用不会阻塞当前线程，调用者可以继续执行其他操作。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncHandleSlice</span><span class="params">(Date date,<span class="type">int</span> bucketId)</span> &#123;</span><br><span class="line">    ...方法逻辑</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="怎么开启线程池并发处理任务的功能"><a href="#怎么开启线程池并发处理任务的功能" class="headerlink" title="怎么开启线程池并发处理任务的功能"></a>怎么开启线程池并发处理任务的功能</h2><p>想要使用线程池的并发处理任务功能，可以使用CompletableFuture提供的方法来方便地进行并发处理任务</p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>本文的CompletableFuture内容参考<a href="https://blog.csdn.net/javaeEEse/article/details/136186918">CompletableFuture使用详解（超详细）-CSDN博客</a></p><p><strong>CompletableFuture</strong>就是帮你处理这些任务之间的逻辑关系，编排好任务的执行方式后，任务会按照规划好的方式一步一步执行，不需要让业务线程去频繁的等待</p><p><strong>函数式编程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;U&gt;  <span class="comment">// 生产者，没有入参，有返回结果</span></span><br><span class="line">Consumer&lt;T&gt;  <span class="comment">// 消费者，有入参，但是没有返回结果</span></span><br><span class="line">Function&lt;T,U&gt;<span class="comment">// 函数，有入参，又有返回结果</span></span><br></pre></td></tr></table></figure><p><strong>先创建一个辅助类方便结果输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">smallTool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleepMillis</span><span class="params">(<span class="type">long</span> millis)</span>&#123;<span class="comment">//该方法主要是模拟线程的休眠</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(millis);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printTimeAndThread</span><span class="params">(String tag)</span>&#123;<span class="comment">//该方法主要是通过接受参数，再将调用该方法的该线程信息输出</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;\t|\t&quot;</span>)</span><br><span class="line">                .add(String.valueOf(System.currentTimeMillis()))</span><br><span class="line">                .add(String.valueOf(Thread.currentThread().getId()))</span><br><span class="line">                .add(Thread.currentThread().getName())</span><br><span class="line">                .add(tag)</span><br><span class="line">                .toString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="supplyAsync（无参，有返回值）"><a href="#supplyAsync（无参，有返回值）" class="headerlink" title="supplyAsync（无参，有返回值）"></a>supplyAsync（无参，有返回值）</h3><p>CompletableFuture中的supplyAsync方法，会开启一个新的线程，和主线程异步同时的执行任务；需要提供返回值，不提供参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白进入餐厅&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白点了菜+饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师打饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;菜和饭做好啦！&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor);<span class="comment">//指定使用的线程池</span></span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在刷视频&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s小白开吃&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><p>小白刷视频和厨师炒菜是同时开始进行的，先后顺序看情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745915054515|1|main|小白进入餐厅</span><br><span class="line">1745915054517|1|main|小白点了菜+饭</span><br><span class="line">1745915054521|1|main|小白在刷视频</span><br><span class="line">1745915054521|25|DataProcessor-1|厨师炒菜</span><br><span class="line">1745915054732|25|DataProcessor-1|厨师打饭</span><br><span class="line">1745915054841|1|main|菜和饭做好啦！小白开吃</span><br></pre></td></tr></table></figure><p>结果说明：开始的执行时间+线程id+线程名称+消息</p><h3 id="runAsync（无参，无返回值）"><a href="#runAsync（无参，无返回值）" class="headerlink" title="runAsync（无参，无返回值）"></a>runAsync（无参，无返回值）</h3><p>runAsync和supplyAsync使用方法相同，唯一的区别就是runAsync没有返回值，执行完代码逻辑后会直接退出</p><h3 id="thenApply（拼接代码）"><a href="#thenApply（拼接代码）" class="headerlink" title="thenApply（拼接代码）"></a>thenApply（拼接代码）</h3><p>thenApply()：把前面任务的执行结果，交给后面的Function，共用同一个线程，可以对前面的返回结果进行一系列处理后再返回</p><p>thenApply相当于把两块代码拼接到了一起，thenApply前面的代码和后面的代码是一起执行的，thenApply只作为拼接的作用，封装两段代码作为一个任务给一个线程去执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白吃完饭&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白准备结账&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1进行结账&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;500元&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenApply(money -&gt;&#123;<span class="comment">//这里共用同一个线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1开小票&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s&quot;</span>,money);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在打电话&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;小白付款%s&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745929093000|1|main|小白吃完饭</span><br><span class="line">1745929093000|1|main|小白准备结账</span><br><span class="line">1745929093002|25|DataProcessor-1|服务员1进行结账</span><br><span class="line">1745929093002|1|main|小白在打电话</span><br><span class="line">1745929093204|25|DataProcessor-1|服务员1开小票</span><br><span class="line">1745929093312|1|main|小白付款500元</span><br></pre></td></tr></table></figure><h3 id="thenApplyAsync"><a href="#thenApplyAsync" class="headerlink" title="thenApplyAsync"></a>thenApplyAsync</h3><p>该方法表示thenApplyAsync前面的代码块和后面的代码块是独立的两个异步任务，并不会像thenApply一样直接拼接，而是会开辟一个新线程来执行独立的任务或者复用原来的线程（虽然复用原来的线程是一个线程，但是异步任务是两个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白吃完饭&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白准备结账&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1进行结账&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;500元&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenApplyAsync(money -&gt;&#123;<span class="comment">//这里共用同一个线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1开小票&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s&quot;</span>,money);</span><br><span class="line">        &#125;,dataProcessingExecutor);</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在打电话&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;小白付款%s&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745928885934|1|main|小白吃完饭</span><br><span class="line">1745928885934|1|main|小白准备结账</span><br><span class="line">1745928885937|25|DataProcessor-1|服务员1进行结账</span><br><span class="line">1745928885937|1|main|小白在打电话</span><br><span class="line">1745928886145|26|DataProcessor-2|服务员1开小票</span><br><span class="line">1745928886255|1|main|小白付款500元</span><br></pre></td></tr></table></figure><h3 id="thenCompose（线程顺序执行）依赖"><a href="#thenCompose（线程顺序执行）依赖" class="headerlink" title="thenCompose（线程顺序执行）依赖"></a>thenCompose（线程顺序执行）依赖</h3><p>thenCompose()：当不同线程的任务执行有先后顺序时，并且依赖其返回值，则使用thenCompose；用来连接两个有依赖关系的任务，结果由第二个任务返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白进入餐厅&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白点了菜+饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;<span class="comment">//新开启一个厨师线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;番茄炒蛋&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenCompose(dish-&gt;CompletableFuture.supplyAsync(()-&gt;&#123;<span class="comment">//新开启一个服务员线程</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员打饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> dish+<span class="string">&quot;饭!&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor));</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在刷视频&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务和服务员打饭完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s小白开吃&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码中使用thenCompose，等待厨师线程完成任务后，有返回值后，下一个任务才会触发；此时”番茄炒蛋”返回值会存入dish中，然后开启一个服务员线程（函数式编程中的Function角色），接收厨师线程的返回值，然后进行一系列操作后，return其对应的返回值</p><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1745917527573|1|main|小白进入餐厅</span><br><span class="line">1745917527573|1|main|小白点了菜+饭</span><br><span class="line">1745917527576|25|DataProcessor-1|厨师炒菜</span><br><span class="line">1745917527576|1|main|小白在刷视频</span><br><span class="line">1745917527776|26|DataProcessor-2|服务员打饭</span><br><span class="line">1745917527887|1|main|番茄炒蛋饭!小白开吃</span><br></pre></td></tr></table></figure><h3 id="thenCombine（线程同时执行）合并"><a href="#thenCombine（线程同时执行）合并" class="headerlink" title="thenCombine（线程同时执行）合并"></a>thenCombine（线程同时执行）合并</h3><p>该方法会使得不同线程异步同时执行，相当于将不同的线程执行进行合并，并且将线程的返回值进行结合返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白进入餐厅&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白点了菜+饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;番茄炒蛋&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).thenCombine(CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员蒸饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;米饭!&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor),(dish,rice)-&gt;&#123;<span class="comment">//将厨师线程和服务员线程的参数接受，然后返回结果</span></span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员打饭&quot;</span>);</span><br><span class="line">            smallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s+%s&quot;</span>,dish,rice);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白在刷视频&quot;</span>);</span><br><span class="line">        <span class="comment">//cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行</span></span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s小白开吃&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1745919339096|1|main|小白进入餐厅</span><br><span class="line">1745919339096|1|main|小白点了菜+饭</span><br><span class="line">1745919339099|25|DataProcessor-1|厨师炒菜</span><br><span class="line">1745919339099|26|DataProcessor-2|服务员蒸饭</span><br><span class="line">1745919339100|1|main|小白在刷视频</span><br><span class="line">1745919339412|26|DataProcessor-2|服务员打饭</span><br><span class="line">1745919339522|1|main|番茄炒蛋+米饭!小白开吃</span><br></pre></td></tr></table></figure><h3 id="exceptionally"><a href="#exceptionally" class="headerlink" title="exceptionally"></a>exceptionally</h3><p>该方法会在supplyAsync执行时，如果执行期间抛出异常，则会直接进入到exceptionally块中，进行对异常处理后返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该程序中的小白是主线程，厨师是开启的新线程</span></span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白吃完饭&quot;</span>);</span><br><span class="line">        smallTool.printTimeAndThread(<span class="string">&quot;小白准备结账&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行</span></span><br><span class="line">        <span class="comment">//supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            smallTool.printTimeAndThread(<span class="string">&quot;服务员1进行结账&quot;</span>);</span><br><span class="line">            <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;小白跑路了！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;500元&quot;</span>;</span><br><span class="line">        &#125;,dataProcessingExecutor).exceptionally(e-&gt;&#123;</span><br><span class="line">           smallTool.printTimeAndThread(e.getMessage());</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;工作人员报警&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        smallTool.printTimeAndThread(String.format(<span class="string">&quot;%s,小白被抓了&quot;</span>,cf1.join()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1745922097054|1|main|小白吃完饭</span><br><span class="line">1745922097054|1|main|小白准备结账</span><br><span class="line">1745922097057|25|DataProcessor-1|服务员1进行结账</span><br><span class="line">1745922097057|1|main|java.lang.RuntimeException: 小白跑路了！</span><br><span class="line">1745922097057|1|main|工作人员报警,小白被抓了</span><br></pre></td></tr></table></figure><h3 id="allOf"><a href="#allOf" class="headerlink" title="allOf"></a>allOf</h3><p>该方法会在所有的CompletableFuture线程异步执行完任务后，主线程才会进行后续操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt;futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//此处模拟10个线程异步并发执行的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            CompletableFuture&lt;Void&gt;future = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务&quot;</span>+ finalI +<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,dataProcessingExecutor);</span><br><span class="line">            <span class="comment">//将CompletableFuture添加进该list中，只有当list中所有的CompletableFuture执行完任务后allOf才放行</span></span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//allOf方法为主线程会等待所有的CompletableFuture开启的线程执行完任务后，才会进行后续执行</span></span><br><span class="line">        CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务执行完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">任务3完成</span><br><span class="line">任务2完成</span><br><span class="line">任务1完成</span><br><span class="line">任务7完成</span><br><span class="line">任务4完成</span><br><span class="line">任务0完成</span><br><span class="line">任务9完成</span><br><span class="line">任务6完成</span><br><span class="line">任务5完成</span><br><span class="line">任务8完成</span><br><span class="line">所有任务执行完成！</span><br></pre></td></tr></table></figure><h3 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf"></a>anyOf</h3><p>futures中如果有线程已经提前执行完了，那么anyOf就会放行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor dataProcessingExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataProcessingExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPool</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt;futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//此处模拟10个线程异步并发执行的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            CompletableFuture&lt;Void&gt;future = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务&quot;</span>+ finalI +<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,dataProcessingExecutor);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture.anyOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">        System.out.println(<span class="string">&quot;已有任务执行完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">任务0完成</span><br><span class="line">任务7完成</span><br><span class="line">任务1完成</span><br><span class="line">已有任务执行完成！</span><br><span class="line">任务4完成</span><br><span class="line">任务8完成</span><br><span class="line">任务9完成</span><br><span class="line">任务2完成</span><br><span class="line">任务5完成</span><br><span class="line">任务3完成</span><br><span class="line">任务6完成</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stream流的入门和使用</title>
      <link href="/2025/04/27/stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/04/27/stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="stream流的概念"><a href="#stream流的概念" class="headerlink" title="stream流的概念"></a>stream流的概念</h1><p>stream流可以看做一条流水线，先将数据读入stream流，在stream流上可以对数据进行一系列处理</p><h1 id="stream流的使用"><a href="#stream流的使用" class="headerlink" title="stream流的使用"></a>stream流的使用</h1><p>stream流可以对单列集合，双列集合，数组，零散数据进行一系列处理，过滤，收集，最后得到想要的结果</p><h2 id="单列集合使用stream流（list、set）"><a href="#单列集合使用stream流（list、set）" class="headerlink" title="单列集合使用stream流（list、set）"></a>单列集合使用stream流（list、set）</h2><p>单列集合通过Collections中的方法获取stream流</p><p>使用stream流的forEach方法来遍历list集合，并且顺序打印他</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //获取一条流水线,将该list集合的数据放到stream流水线上（stream流的匿名内部类的用法）</span></span><br><span class="line"><span class="comment">        Stream&lt;String&gt; stream = list.stream();</span></span><br><span class="line"><span class="comment">        stream.forEach(new Consumer&lt;String&gt;() &#123;//使用forEach来遍历list集合</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void accept(String s)&#123;//这里的s表示list集合中的一条数据</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以使用stream的链式调用（lambda）简化操作，这里的s代表list集合中的一条数据</span></span><br><span class="line">        <span class="comment">//s代表上面的匿名内部类的形参，-&gt;后面的操作是该形参的操作方法</span></span><br><span class="line">        list.stream().forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双列集合使用stream流（map）"><a href="#双列集合使用stream流（map）" class="headerlink" title="双列集合使用stream流（map）"></a>双列集合使用stream流（map）</h2><p>双列集合不能直接使用stream流，需要map先获取到key或entryKey后，才可以获取到stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;aaa&quot;</span>,<span class="number">111</span>);</span><br><span class="line">        map.put(<span class="string">&quot;bbb&quot;</span>,<span class="number">222</span>);</span><br><span class="line">        map.put(<span class="string">&quot;ccc&quot;</span>,<span class="number">33</span>);</span><br><span class="line">        map.put(<span class="string">&quot;ddd&quot;</span>,<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//map不能直接获取stream流，需要进行中转</span></span><br><span class="line">        <span class="comment">//1.map可以先通过获取键集合后，之后使用stream流</span></span><br><span class="line">        map.keySet().stream().forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.map也可以通过键值对集合后，使用stream流</span></span><br><span class="line">        map.entrySet().stream().forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">ccc</span><br><span class="line">bbb</span><br><span class="line">ddd</span><br><span class="line">=============</span><br><span class="line">aaa=111</span><br><span class="line">ccc=33</span><br><span class="line">bbb=222</span><br><span class="line">ddd=44</span><br></pre></td></tr></table></figure><h2 id="数组使用stream流"><a href="#数组使用stream流" class="headerlink" title="数组使用stream流"></a>数组使用stream流</h2><p>数组可以通过Arrays直接使用stream流，将数组名传入即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[]arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        String[]str = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//数组使用stream流可以直接通过Arrays方法，将数组名传入即可</span></span><br><span class="line">        Arrays.stream(arr).forEach(s-&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.stream(str).forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="零散的数据使用stream流"><a href="#零散的数据使用stream流" class="headerlink" title="零散的数据使用stream流"></a>零散的数据使用stream流</h2><p>零散的数据可以直接通过stream的of方法，进行使用stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).forEach(s-&gt; System.out.println(s));</span><br><span class="line">        Stream.of(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;cd&quot;</span>,<span class="string">&quot;ef&quot;</span>).forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stream流的中间方法"><a href="#stream流的中间方法" class="headerlink" title="stream流的中间方法"></a>stream流的中间方法</h1><p><strong>stream流的中间方法使用后会生成一个新的stream流，原stream流调用中间方法后就会关闭，不能使用了</strong></p><p><strong>中间方法只会修改stream流，传入stream流的原始数据不会变化</strong></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)----》过滤</span><br><span class="line">Stream&lt;T&gt; limit(long maxSize)----》获取前几个元素</span><br><span class="line">Stream&lt;T&gt; skip(long n)----》跳过前几个元素</span><br><span class="line">Stream&lt;T&gt; distinct()----》元素去重，依赖(hashCode和equals方法)</span><br><span class="line">static &lt;T&gt; Stream&lt;T&gt; concat(Stream a, Stream b)----》合并a和b两个流为一个流</span><br><span class="line">Stream&lt;R&gt; map(Function&lt;T ,R&gt; mapper)----》转换流中的数据类型</span><br></pre></td></tr></table></figure><h2 id="filter方法"><a href="#filter方法" class="headerlink" title="filter方法"></a>filter方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>,<span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张翠山&quot;</span>,<span class="string">&quot;张良&quot;</span>,<span class="string">&quot;王二麻子&quot;</span>,<span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //先使用stream流的匿名内部类的方式</span></span><br><span class="line"><span class="comment">        Stream&lt;String&gt; stream = list.stream();</span></span><br><span class="line"><span class="comment">        stream.filter(new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">                //如果为true则该条数据留下，如果startsWith判断该条记录是&#x27;张&#x27;开头的数据则返回true</span></span><br><span class="line"><span class="comment">                //如果为false则该条数据丢弃</span></span><br><span class="line"><span class="comment">                if(s.startsWith(&quot;张&quot;))return true;</span></span><br><span class="line"><span class="comment">                else return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).forEach(s-&gt; System.out.println(s));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用stream流的lambda表达式进行链式调用</span></span><br><span class="line">        <span class="comment">// s代表遍历过程中的一条记录，filter会判断当前记录是否是张开头，如果是则保留</span></span><br><span class="line">        list.stream().filter(s-&gt;s.startsWith(<span class="string">&quot;张&quot;</span>)).forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">张无忌</span><br><span class="line">张强</span><br><span class="line">张三丰</span><br><span class="line">张翠山</span><br><span class="line">张良</span><br></pre></td></tr></table></figure><h2 id="skip和limit方法"><a href="#skip和limit方法" class="headerlink" title="skip和limit方法"></a>skip和limit方法</h2><p>skip：跳过集合的前几个元素</p><p>limit：获取集合的前几个元素</p><p>这两个方法都是基于前一个中间方法操作后的新stream流的数据进行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>,<span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张翠山&quot;</span>,<span class="string">&quot;张良&quot;</span>,<span class="string">&quot;王二麻子&quot;</span>,<span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//skip表示跳过该集合的前3条记录，limit表示只显示该集合的4-7条记录</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .skip(<span class="number">3</span>)</span><br><span class="line">                .limit(<span class="number">4</span>)</span><br><span class="line">                .forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">张强</span><br><span class="line">张三丰</span><br><span class="line">张翠山</span><br><span class="line">张良</span><br></pre></td></tr></table></figure><h2 id="distinct和concat方法"><a href="#distinct和concat方法" class="headerlink" title="distinct和concat方法"></a>distinct和concat方法</h2><p>distinct：给集合中的元素去重，如果是list中存放的是自定义类，需要重写HashCode和equals方法才会生效</p><p>concat：Stream流的静态方法，用来合并stream流里的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list1,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list2,<span class="string">&quot;sky&quot;</span>,<span class="string">&quot;okk&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//distinct表示给集合去重，如果是list中存放的是自定义类，需要重写HashCode和equals方法才会生效</span></span><br><span class="line">        list1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(s-&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并两个stream流</span></span><br><span class="line">        Stream.concat(list1.stream(),list2.stream()).forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">张无忌</span><br><span class="line">周芷若</span><br><span class="line">谢广坤</span><br><span class="line">==============</span><br><span class="line">张无忌</span><br><span class="line">张无忌</span><br><span class="line">张无忌</span><br><span class="line">周芷若</span><br><span class="line">谢广坤</span><br><span class="line">sky</span><br><span class="line">okk</span><br></pre></td></tr></table></figure><h2 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h2><p>map方法用来给集合中的元素一系列处理（类型转换，修改数据）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌-15&quot;</span>,<span class="string">&quot;周芷若-14&quot;</span>,<span class="string">&quot;赵敏-13&quot;</span>,<span class="string">&quot;张强-20&quot;</span>,<span class="string">&quot;张三丰-100&quot;</span>,<span class="string">&quot;张翠山-40&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当想要对list中的数据进行类型转换时，使用stream流中的map方法（匿名内部类形式）</span></span><br><span class="line">        list.stream().map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;<span class="comment">//需要获取String字符串中的数字</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="comment">//s表示遍历集合过程中的一条记录</span></span><br><span class="line">                <span class="comment">//先进行分割字符串，再提取数字，最后类型转换返回age</span></span><br><span class="line">                String[] strings = s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strings[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">                <span class="keyword">return</span> age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).forEach(s-&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用map方法的lambda形式</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .map(s-&gt;Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream的终结方法"><a href="#Stream的终结方法" class="headerlink" title="Stream的终结方法"></a>Stream的终结方法</h1><p><strong>终结方法：当stream流执行完终结方法后就会退出stream流，然后返回</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void forEach(Consumer action)----&gt;遍历</span><br><span class="line">long count()----&gt;统计</span><br><span class="line">toArray()----&gt;收集流中的数据，放到数组中</span><br><span class="line">collect(Collector collector)----&gt;收集流中的数据，放到集合中</span><br></pre></td></tr></table></figure><h2 id="forEach和count方法"><a href="#forEach和count方法" class="headerlink" title="forEach和count方法"></a>forEach和count方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌-15&quot;</span>,<span class="string">&quot;周芷若-14&quot;</span>,<span class="string">&quot;赵敏-13&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//forEach用来遍历集合</span></span><br><span class="line">        list.stream().forEach(s-&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//count用来统计集合个数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toArray方法"><a href="#toArray方法" class="headerlink" title="toArray方法"></a>toArray方法</h2><p>stream流的toArray方法会先创建一个数组，然后stream流将list中的数据一个个赋值到该数组中，最后返回该数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌-15&quot;</span>,<span class="string">&quot;周芷若-14&quot;</span>,<span class="string">&quot;赵敏-13&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//toArray方法用来将集合变为数组</span></span><br><span class="line">        <span class="comment">//1.将集合转换为默认Object类型的数组</span></span><br><span class="line">        Object[] arr1 = list.stream().toArray();</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1使用匿名内部类的方式，将集合转换为指定类型的数组</span></span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        String[] arr2 = stream.toArray(<span class="keyword">new</span> <span class="title class_">IntFunction</span>&lt;String[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String[] apply(<span class="type">int</span> value) &#123;<span class="comment">//value表示数组长度</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[value];<span class="comment">//这里面填写数组长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2使用lambda表达式，将集合转换为指定类型的数组</span></span><br><span class="line">        <span class="comment">//lambda表达式省略return，会将new String[value]该值直接返回</span></span><br><span class="line">        String[] arr3 = list.stream().toArray(value -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[value]);</span><br><span class="line">        System.out.println(Arrays.toString(arr3));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[张无忌-<span class="number">15</span>, 周芷若-<span class="number">14</span>, 赵敏-<span class="number">13</span>]</span><br><span class="line">[张无忌-<span class="number">15</span>, 周芷若-<span class="number">14</span>, 赵敏-<span class="number">13</span>]</span><br><span class="line">[张无忌-<span class="number">15</span>, 周芷若-<span class="number">14</span>, 赵敏-<span class="number">13</span>]</span><br></pre></td></tr></table></figure><h2 id="collect方法-将数据转换为List-Set-Map集合"><a href="#collect方法-将数据转换为List-Set-Map集合" class="headerlink" title="collect方法(将数据转换为List,Set,Map集合)"></a>collect方法(将数据转换为List,Set,Map集合)</h2><p>stream流的collect方法可以将数据进行一系列处理后，转换为不同的集合</p><p><strong>将数据收集到list和set中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌-男-15&quot;</span>,<span class="string">&quot;张无忌-男-15&quot;</span>,<span class="string">&quot;周芷若-女-14&quot;</span>,<span class="string">&quot;赵敏-女-13&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收集所有为男性的信息到list中</span></span><br><span class="line">        List&lt;String&gt; list1 = list.stream()</span><br><span class="line">                .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收集所有为男性的信息到set中,收集到set中时会自动去重</span></span><br><span class="line">        Set&lt;String&gt; set = list.stream()</span><br><span class="line">                .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[张无忌-男-<span class="number">15</span>, 张无忌-男-<span class="number">15</span>]</span><br><span class="line">[张无忌-男-<span class="number">15</span>]</span><br></pre></td></tr></table></figure><p><strong>将数据收集到map中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkTestApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌-男-15&quot;</span>,<span class="string">&quot;sky-男-16&quot;</span>,<span class="string">&quot;周芷若-女-14&quot;</span>,<span class="string">&quot;赵敏-女-13&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.使用匿名内部类，收集数据到map中</span></span><br><span class="line">        <span class="comment">//将数据收集到map中，需要定义键值对的规则，如果存入map中的key重复时会抛出异常(例如当有两个张无忌存在时，java.lang.IllegalStateException: Duplicate key 15)</span></span><br><span class="line">        <span class="comment">//此处将list中的姓名作为key，年龄作为value</span></span><br><span class="line">        Map&lt;String, Integer&gt; map1 = list.stream()</span><br><span class="line">                .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .collect(Collectors.toMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, String&gt;() &#123;<span class="comment">//第一部分是键的规则</span></span><br><span class="line">                    <span class="comment">//键的定义规则：在new Function&lt;String, String&gt;中第一个String指的是apply方法的形参（即集合中的数据）</span></span><br><span class="line">                    <span class="comment">// 第二个String表示apply方法的返回值，将该返回值作为map的key</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;<span class="comment">//第二部分是值的规则</span></span><br><span class="line">                    <span class="comment">//值的定义规则和键的相同，new Function&lt;String, Integer&gt;中第一个参数String为形参（list中的数据）</span></span><br><span class="line">                    <span class="comment">//第二个参数Integer则表示apply方法的返回值，将该返回值作为map的value</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;));</span><br><span class="line">        System.out.println(map1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使用lambda表达式，将数据收集到map中</span></span><br><span class="line">        Map&lt;String, Integer&gt; map2 = list.stream()</span><br><span class="line">                .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .collect(Collectors.toMap(s1-&gt;s1.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>],s2-&gt;Integer.parseInt(s2.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>])));</span><br><span class="line">        System.out.println(map2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;sky=<span class="number">16</span>, 张无忌=<span class="number">15</span>&#125;</span><br><span class="line">===========</span><br><span class="line">&#123;sky=<span class="number">16</span>, 张无忌=<span class="number">15</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stream流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术的那点事</title>
      <link href="/2025/04/16/%E4%B8%9A%E5%8A%A1%E7%A7%AF%E7%B4%AF/"/>
      <url>/2025/04/16/%E4%B8%9A%E5%8A%A1%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="技术积累"><a href="#技术积累" class="headerlink" title="技术积累"></a>技术积累</h2><h3 id="全局异常捕获和状态码返回"><a href="#全局异常捕获和状态码返回" class="headerlink" title="全局异常捕获和状态码返回"></a>全局异常捕获和状态码返回</h3><p><strong>怎么定义全局异常？</strong> </p><p>想要使用全局异常首先需要定义一个<code>GlobalExceptionHandler.java</code>类和自定义异常类<code>DatabaseSetDataException</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseSetDataException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DatabaseSetDataException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(DatabaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Wrapper <span class="title function_">handleDataAccessException</span><span class="params">(DatabaseSetDataException ex)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;数据库操作失败: &quot;</span>+ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> Wrapper.ERROR_BUILDER <span class="comment">//在这里调用wrapper的Eror_builder会将Wrapper里原先设置的code(-1)进行覆盖，不会产生两个code</span></span><br><span class="line">                .code(ex.getCode())</span><br><span class="line">                .message(<span class="string">&quot;操作失败&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Wrapper是什么？</strong></p><p>Wrapper是状态码的统一返回规范类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span><span class="comment">//启用builder构建者模式</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wrapper</span> <span class="keyword">implements</span> <span class="title class_">ResponseRestful</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功响应 Builder</span></span><br><span class="line">    <span class="comment">//如果使用SUCCESS的话，会先调用suc_builder进行拼接code和message</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">WrapperBuilder</span> <span class="variable">SUCCESS_BUILDER</span> <span class="operator">=</span> Wrapper.builder().code(<span class="number">0</span>).data(<span class="number">0</span>).message(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Wrapper</span> <span class="variable">SUCCESS</span> <span class="operator">=</span> SUCCESS_BUILDER.build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用错误 Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">WrapperBuilder</span> <span class="variable">ERROR_BUILDER</span> <span class="operator">=</span> Wrapper.builder().code(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Wrapper</span> <span class="variable">ERROR</span> <span class="operator">=</span> ERROR_BUILDER.message(<span class="string">&quot;ERROR&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会话错误 Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">WrapperBuilder</span> <span class="variable">SESSION_ERROR_BUILDER</span> <span class="operator">=</span> Wrapper.builder().code(<span class="number">510</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Builder构建者模式的使用</strong></p><p>拿上面的Wrapper举例，里面的<code>WrapperBuilder SUCCESS_BUILDER = Wrapper.builder().code(0).data(0).message(&quot;OK&quot;);</code>相当于构建了一个WrapperBuilder对象；只有当<code>Wrapper SUCCESS = SUCCESS_BUILDER.build();</code>使用了builde（）方法，才算是对象构建完成。可以理解为new Wrapper（），然后set属性</p><p><strong>怎么抛出异常，然后被全局异常捕获</strong></p><p>此处是在service层抛出异常，然后被全局异常处理器捕获</p><p>在可能出现异常的地方进行try-catch，catch的异常就是自定义的数据库异常，捕获异常后可以进行对应的异常抛出和处理；当抛出DatabaseSetDataException后会被全局异常处理器捕获到，最后返回对应的错误码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YyAppointmentInfoServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;YyAppointmentInfoMapper, YyAppointmentInfo&gt; <span class="keyword">implements</span> <span class="title class_">IYyAppointmentInfoService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    YyAppointmentInfoMapper yyAppointmentInfoMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataExceptionHandImpl dataExceptionHand;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAppointInfo</span><span class="params">(YyAppointmentInfo appointmentInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            appointmentInfo.setRksj(LocalDateTime.now());</span><br><span class="line">            yyAppointmentInfoMapper.insert(appointmentInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            <span class="comment">//将存入数据异常的对象存入，传入对应的type，异常信息</span></span><br><span class="line">            dataExceptionHand.handleInsertException(appointmentInfo,<span class="number">0</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode更新博客要点</title>
      <link href="/2025/04/15/vscode%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%A6%81%E7%82%B9/"/>
      <url>/2025/04/15/vscode%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo博客更新"><a href="#hexo博客更新" class="headerlink" title="hexo博客更新"></a>hexo博客更新</h2><p>需要新增一篇博客时直接在blog文件夹下hexo new “文件名”</p><hr><h2 id="推送信息"><a href="#推送信息" class="headerlink" title="推送信息"></a>推送信息</h2><p>当在vscode更新时需要每次从本地提交到远程，再重新启动才会生效<br>修改完内容后：</p><ol><li>git add -A(添加到缓冲区)</li><li>git commit -m “此次修改的描述信息”</li><li>git push(推送到远程;如果出现fatal: unable to access ‘<a href="https://github.com/legend578/legend578.github.io.git/">https://github.com/legend578/legend578.github.io.git/</a>‘: Failed to connect to 127.0.0.1 port 7897 after 2107 ms: Could not connect to server则进行开启clash代理)<br>hexo d（使得网站重新生效）</li></ol><hr><h2 id="怎么将博客放入到标签和分类中"><a href="#怎么将博客放入到标签和分类中" class="headerlink" title="怎么将博客放入到标签和分类中"></a>怎么将博客放入到标签和分类中</h2><p>在每篇博客的顶部，进行设置categories和tags，想要将该博客归属到哪，就在下面编写对应文字<br><img src="/img/vscode1.png" width="auto" height="auto"></p><h2 id="怎么在博客中插入图片"><a href="#怎么在博客中插入图片" class="headerlink" title="怎么在博客中插入图片"></a>怎么在博客中插入图片</h2><p>使用<img src="/img/vscode1.png" width="auto" height="auto">，使用img标签即可，src填写图片路径，可以是外部图片，也可以是本机图片</p>]]></content>
      
      
      <categories>
          
          <category> 博客初始化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客怎么更新 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
