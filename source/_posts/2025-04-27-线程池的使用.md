---
title: 线程池的异步并发操作以及CompletableFuture的使用
date: 2025-04-27 21:43:58
categories: # 分类
	- 技术点  # 只能由一个
tags: # 标签
	- 线程池 
---

## 怎么定义线程池

### 实例化线程池作为bean注入到spring容器

通过ThreadPoolTaskExecutor创建一个线程池，自定义线程池参数，最后将该线程池作为bean注入到spring容器中

```Java
@Configuration
@EnableAsync
public class ThreadPoolConfig {

    @Bean(name = "dataProcessingExecutor")
    public ThreadPoolTaskExecutor dataProcessingExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 2);
        executor.setMaxPoolSize(100);
        executor.setQueueCapacity(10000);
        executor.setThreadNamePrefix("DataProcessor-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
    @Bean(name = "exceptionDataProcessingExecutor")
    public ThreadPoolTaskExecutor exceptionDataProcessingExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 2);
        executor.setMaxPoolSize(100);
        executor.setQueueCapacity(10000);
        executor.setThreadNamePrefix("ExceptionDataProcessor-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}

```



## 怎么开启线程池的异步处理功能

1.在application启动类上添加@EnableAsync注解

```java
@SpringBootApplication(scanBasePackages = {"cn.bitoffer"})
@EnableScheduling
@EnableAsync
public class XTimerApplication {

    public static void main(String[] args) {
        SpringApplication.run(XTimerApplication.class, args);
    }

}
```

2.在实例化线程池时添加@EnableAsync注解

```Java
@Configuration
@EnableAsync//运行方法异步执行
public class ThreadPoolConfig {
...
}
```

3.对需要异步处理的方法添加@Async("schedulerPool")注解，表示当前方法会放入线程池中异步处理

```Java
@Async("dataProcessingExecutor")
//@Async("dataProcessingExecutor")：这个注解表示 asyncHandleSlice 方法会在一个新的线程中异步执行。
//Spring会将这个方法提交给名为 dataProcessingExecutor 的线程池
//异步执行意味着该方法的调用不会阻塞当前线程，调用者可以继续执行其他操作。
    public void asyncHandleSlice(Date date,int bucketId) {
    ...方法逻辑
    }
```



## 怎么开启线程池并发处理任务的功能

想要使用线程池的并发处理任务功能，可以使用CompletableFuture提供的方法来方便地进行并发处理任务

### CompletableFuture

本文的CompletableFuture内容参考[CompletableFuture使用详解（超详细）-CSDN博客](https://blog.csdn.net/javaeEEse/article/details/136186918)

**CompletableFuture**就是帮你处理这些任务之间的逻辑关系，编排好任务的执行方式后，任务会按照规划好的方式一步一步执行，不需要让业务线程去频繁的等待



**函数式编程**

```Java
Supplier<U>  // 生产者，没有入参，有返回结果
Consumer<T>  // 消费者，有入参，但是没有返回结果
Function<T,U>// 函数，有入参，又有返回结果
```



**先创建一个辅助类方便结果输出**

```Java
public class smallTool {
    public static void sleepMillis(long millis){//该方法主要是模拟线程的休眠
        try{
            Thread.sleep(millis);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }

    public static void printTimeAndThread(String tag){//该方法主要是通过接受参数，再将调用该方法的该线程信息输出
        String result = new StringJoiner("\t|\t")
                .add(String.valueOf(System.currentTimeMillis()))
                .add(String.valueOf(Thread.currentThread().getId()))
                .add(Thread.currentThread().getName())
                .add(tag)
                .toString();
        System.out.println(result);
    }
}
```



### supplyAsync（无参，有返回值）

CompletableFuture中的supplyAsync方法，会开启一个新的线程，和主线程异步同时的执行任务；需要提供返回值，不提供参数

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Resource(name = "dataProcessingExecutor")
    private ThreadPoolTaskExecutor dataProcessingExecutor;

    @Test
    @Async("dataProcessingExecutor")
    public void testPool(){
        //该程序中的小白是主线程，厨师是开启的新线程
        smallTool.printTimeAndThread("小白进入餐厅");
        smallTool.printTimeAndThread("小白点了菜+饭");

        //当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行
        //supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色
        CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(()->{
            smallTool.printTimeAndThread("厨师炒菜");
            smallTool.sleepMillis(200);
            smallTool.printTimeAndThread("厨师打饭");
            smallTool.sleepMillis(100);
            return "菜和饭做好啦！";
        },dataProcessingExecutor);//指定使用的线程池

        smallTool.printTimeAndThread("小白在刷视频");
        //cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行
        smallTool.printTimeAndThread(String.format("%s小白开吃",cf1.join()));
    }
}
```



**输出结果**

小白刷视频和厨师炒菜是同时开始进行的，先后顺序看情况

```
1745915054515	|	1	|	main	|	小白进入餐厅
1745915054517	|	1	|	main	|	小白点了菜+饭
1745915054521	|	1	|	main	|	小白在刷视频
1745915054521	|	25	|	DataProcessor-1	|	厨师炒菜
1745915054732	|	25	|	DataProcessor-1	|	厨师打饭
1745915054841	|	1	|	main	|	菜和饭做好啦！小白开吃
```

结果说明：开始的执行时间+线程id+线程名称+消息



### runAsync（无参，无返回值）

runAsync和supplyAsync使用方法相同，唯一的区别就是runAsync没有返回值，执行完代码逻辑后会直接退出



### thenApply（拼接代码）

thenApply()：把前面任务的执行结果，交给后面的Function，共用同一个线程，可以对前面的返回结果进行一系列处理后再返回

thenApply相当于把两块代码拼接到了一起，thenApply前面的代码和后面的代码是一起执行的，thenApply只作为拼接的作用，封装两段代码作为一个任务给一个线程去执行

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Resource(name = "dataProcessingExecutor")
    private ThreadPoolTaskExecutor dataProcessingExecutor;

    @Test
    @Async("dataProcessingExecutor")
    public void testPool(){
        //该程序中的小白是主线程，厨师是开启的新线程
        smallTool.printTimeAndThread("小白吃完饭");
        smallTool.printTimeAndThread("小白准备结账");

        //当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行
        //supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色
        CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(()->{
            smallTool.printTimeAndThread("服务员1进行结账");
            smallTool.sleepMillis(200);
            return "500元";
        },dataProcessingExecutor).thenApply(money ->{//这里共用同一个线程
            smallTool.printTimeAndThread("服务员1开小票");
            smallTool.sleepMillis(100);
            return String.format("%s",money);
        });

        smallTool.printTimeAndThread("小白在打电话");
        //cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行
        smallTool.printTimeAndThread(String.format("小白付款%s",cf1.join()));
    }
}

```



**输出结果**

```
1745929093000	|	1	|	main	|	小白吃完饭
1745929093000	|	1	|	main	|	小白准备结账
1745929093002	|	25	|	DataProcessor-1	|	服务员1进行结账
1745929093002	|	1	|	main	|	小白在打电话
1745929093204	|	25	|	DataProcessor-1	|	服务员1开小票
1745929093312	|	1	|	main	|	小白付款500元
```



### thenApplyAsync

该方法表示thenApplyAsync前面的代码块和后面的代码块是独立的两个异步任务，并不会像thenApply一样直接拼接，而是会开辟一个新线程来执行独立的任务或者复用原来的线程（虽然复用原来的线程是一个线程，但是异步任务是两个）

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Resource(name = "dataProcessingExecutor")
    private ThreadPoolTaskExecutor dataProcessingExecutor;

    @Test
    @Async("dataProcessingExecutor")
    public void testPool(){
        //该程序中的小白是主线程，厨师是开启的新线程
        smallTool.printTimeAndThread("小白吃完饭");
        smallTool.printTimeAndThread("小白准备结账");

        //当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行
        //supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色
        CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(()->{
            smallTool.printTimeAndThread("服务员1进行结账");
            smallTool.sleepMillis(200);
            return "500元";
        },dataProcessingExecutor).thenApplyAsync(money ->{//这里共用同一个线程
            smallTool.printTimeAndThread("服务员1开小票");
            smallTool.sleepMillis(100);
            return String.format("%s",money);
        },dataProcessingExecutor);

        smallTool.printTimeAndThread("小白在打电话");
        //cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行
        smallTool.printTimeAndThread(String.format("小白付款%s",cf1.join()));
    }
}
```

**输出结果**

```
1745928885934	|	1	|	main	|	小白吃完饭
1745928885934	|	1	|	main	|	小白准备结账
1745928885937	|	25	|	DataProcessor-1	|	服务员1进行结账
1745928885937	|	1	|	main	|	小白在打电话
1745928886145	|	26	|	DataProcessor-2	|	服务员1开小票
1745928886255	|	1	|	main	|	小白付款500元
```





### thenCompose（线程顺序执行）依赖

thenCompose()：当不同线程的任务执行有先后顺序时，并且依赖其返回值，则使用thenCompose；用来连接两个有依赖关系的任务，结果由第二个任务返回

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Resource(name = "dataProcessingExecutor")
    private ThreadPoolTaskExecutor dataProcessingExecutor;

    @Test
    @Async("dataProcessingExecutor")
    public void testPool(){
        //该程序中的小白是主线程，厨师是开启的新线程
        smallTool.printTimeAndThread("小白进入餐厅");
        smallTool.printTimeAndThread("小白点了菜+饭");

        //当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行
        //supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色
        CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(()->{//新开启一个厨师线程
            smallTool.printTimeAndThread("厨师炒菜");
            smallTool.sleepMillis(200);
            return "番茄炒蛋";
        },dataProcessingExecutor).thenCompose(dish->CompletableFuture.supplyAsync(()->{//新开启一个服务员线程
            smallTool.printTimeAndThread("服务员打饭");
            smallTool.sleepMillis(100);
            return dish+"饭!";
        },dataProcessingExecutor));

        smallTool.printTimeAndThread("小白在刷视频");
        //cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务和服务员打饭完成后，并且得到返回值，主线程才会继续执行
        smallTool.printTimeAndThread(String.format("%s小白开吃",cf1.join()));
    }
}
```

该代码中使用thenCompose，等待厨师线程完成任务后，有返回值后，下一个任务才会触发；此时"番茄炒蛋"返回值会存入dish中，然后开启一个服务员线程（函数式编程中的Function角色），接收厨师线程的返回值，然后进行一系列操作后，return其对应的返回值



**输出结果**

```
1745917527573	|	1	|	main	|	小白进入餐厅
1745917527573	|	1	|	main	|	小白点了菜+饭
1745917527576	|	25	|	DataProcessor-1	|	厨师炒菜
1745917527576	|	1	|	main	|	小白在刷视频
1745917527776	|	26	|	DataProcessor-2	|	服务员打饭
1745917527887	|	1	|	main	|	番茄炒蛋饭!小白开吃
```



### thenCombine（线程同时执行）合并

该方法会使得不同线程异步同时执行，相当于将不同的线程执行进行合并，并且将线程的返回值进行结合返回

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Resource(name = "dataProcessingExecutor")
    private ThreadPoolTaskExecutor dataProcessingExecutor;

    @Test
    @Async("dataProcessingExecutor")
    public void testPool(){
        //该程序中的小白是主线程，厨师是开启的新线程
        smallTool.printTimeAndThread("小白进入餐厅");
        smallTool.printTimeAndThread("小白点了菜+饭");

        //当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行
        //supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色
        CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(()->{
            smallTool.printTimeAndThread("厨师炒菜");
            smallTool.sleepMillis(200);
            return "番茄炒蛋";
        },dataProcessingExecutor).thenCombine(CompletableFuture.supplyAsync(()->{
            smallTool.printTimeAndThread("服务员蒸饭");
            smallTool.sleepMillis(300);
            return "米饭!";
        },dataProcessingExecutor),(dish,rice)->{//将厨师线程和服务员线程的参数接受，然后返回结果
            smallTool.printTimeAndThread("服务员打饭");
            smallTool.sleepMillis(100);
            return String.format("%s+%s",dish,rice);
        });

        smallTool.printTimeAndThread("小白在刷视频");
        //cf1.join()会使得主线程小白等待cf1厨师线程的炒菜任务完成后，并且得到返回值，主线程才会继续执行
        smallTool.printTimeAndThread(String.format("%s小白开吃",cf1.join()));
    }
}
```



**输出结果**

```
1745919339096	|	1	|	main	|	小白进入餐厅
1745919339096	|	1	|	main	|	小白点了菜+饭
1745919339099	|	25	|	DataProcessor-1	|	厨师炒菜
1745919339099	|	26	|	DataProcessor-2	|	服务员蒸饭
1745919339100	|	1	|	main	|	小白在刷视频
1745919339412	|	26	|	DataProcessor-2	|	服务员打饭
1745919339522	|	1	|	main	|	番茄炒蛋+米饭!小白开吃
```



### exceptionally

该方法会在supplyAsync执行时，如果执行期间抛出异常，则会直接进入到exceptionally块中，进行对异常处理后返回

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Resource(name = "dataProcessingExecutor")
    private ThreadPoolTaskExecutor dataProcessingExecutor;

    @Test
    @Async("dataProcessingExecutor")
    public void testPool(){
        //该程序中的小白是主线程，厨师是开启的新线程
        smallTool.printTimeAndThread("小白吃完饭");
        smallTool.printTimeAndThread("小白准备结账");

        //当使用CompletableFuture.supplyAsync执行时，会开启一个新线程，和主线程异步同时执行
        //supplyAsync该方法必须有返回值，但不接收参数；是函数式编程中的supplier供应者角色
        CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(()->{
            smallTool.printTimeAndThread("服务员1进行结账");
            int i=0;
            if(i==0) throw new RuntimeException("小白跑路了！");
            return "500元";
        },dataProcessingExecutor).exceptionally(e->{
           smallTool.printTimeAndThread(e.getMessage());
           return "工作人员报警";
        });
        smallTool.printTimeAndThread(String.format("%s,小白被抓了",cf1.join()));
    }
}

```



**输出结果**

```
1745922097054	|	1	|	main	|	小白吃完饭
1745922097054	|	1	|	main	|	小白准备结账
1745922097057	|	25	|	DataProcessor-1	|	服务员1进行结账
1745922097057	|	1	|	main	|	java.lang.RuntimeException: 小白跑路了！
1745922097057	|	1	|	main	|	工作人员报警,小白被抓了
```



### allOf

该方法会在所有的CompletableFuture线程异步执行完任务后，主线程才会进行后续操作

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Resource(name = "dataProcessingExecutor")
    private ThreadPoolTaskExecutor dataProcessingExecutor;

    @Test
    @Async("dataProcessingExecutor")
    public void testPool(){
        List<CompletableFuture<Void>>futures = new ArrayList<>();
        //此处模拟10个线程异步并发执行的情况
        for(int i=0;i<10;i++){
            int finalI = i;
            CompletableFuture<Void>future = CompletableFuture.runAsync(()->{
                try {
                    Thread.sleep(1000);
                    System.out.println("任务"+ finalI +"完成");
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            },dataProcessingExecutor);
            //将CompletableFuture添加进该list中，只有当list中所有的CompletableFuture执行完任务后allOf才放行
            futures.add(future);
        }
        //allOf方法为主线程会等待所有的CompletableFuture开启的线程执行完任务后，才会进行后续执行
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        System.out.println("所有任务执行完成！");
    }
}
```



**输出结果**

```
任务3完成
任务2完成
任务1完成
任务7完成
任务4完成
任务0完成
任务9完成
任务6完成
任务5完成
任务8完成
所有任务执行完成！
```



### anyOf

futures中如果有线程已经提前执行完了，那么anyOf就会放行

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Resource(name = "dataProcessingExecutor")
    private ThreadPoolTaskExecutor dataProcessingExecutor;

    @Test
    @Async("dataProcessingExecutor")
    public void testPool(){
        List<CompletableFuture<Void>>futures = new ArrayList<>();
        //此处模拟10个线程异步并发执行的情况
        for(int i=0;i<10;i++){
            int finalI = i;
            CompletableFuture<Void>future = CompletableFuture.runAsync(()->{
                try {
                    Thread.sleep(1000);
                    System.out.println("任务"+ finalI +"完成");
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            },dataProcessingExecutor);
            futures.add(future);
        }
        CompletableFuture.anyOf(futures.toArray(new CompletableFuture[0])).join();
        System.out.println("已有任务执行完成！");
    }
}
```



**输出结果**

```
任务0完成
任务7完成
任务1完成
已有任务执行完成！
任务4完成
任务8完成
任务9完成
任务2完成
任务5完成
任务3完成
任务6完成
```

