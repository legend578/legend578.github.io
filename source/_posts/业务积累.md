---
title: 技术的那点事
date: 2025-04-16 10:15:03
categories: # 分类
	- 技术点  # 只能由一个
tags: # 标签
	- 业务  # 能有多个
	- 技术  # 一个标签一行
---


## 技术积累

### 全局异常捕获和状态码返回

**怎么定义全局异常？** 

想要使用全局异常首先需要定义一个`GlobalExceptionHandler.java`类和自定义异常类`DatabaseSetDataException` 

```Java
@Getter
@Setter
public class DatabaseSetDataException extends RuntimeException {

    private Integer code = 50001;
    private String message;

    public DatabaseSetDataException(String message){
        this.message = message;
    }

}
```

```Java
@Slf4j
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {
    // 数据库异常
    @ExceptionHandler(DatabaseException.class)
    public Wrapper handleDataAccessException(DatabaseSetDataException ex) {
        log.error("数据库操作失败: "+ex.getMessage());
        return Wrapper.ERROR_BUILDER //在这里调用wrapper的Eror_builder会将Wrapper里原先设置的code(-1)进行覆盖，不会产生两个code
                .code(ex.getCode())
                .message("操作失败")
                .build();
    }

}
```



**Wrapper是什么？**

Wrapper是状态码的统一返回规范类

```Java
@Data
@Builder//启用builder构建者模式
@NoArgsConstructor
@AllArgsConstructor
public class Wrapper implements ResponseRestful {

    private int code;

    private String message;

    @Getter
    private Object data;

    // 成功响应 Builder
    //如果使用SUCCESS的话，会先调用suc_builder进行拼接code和message
    public static final WrapperBuilder SUCCESS_BUILDER = Wrapper.builder().code(0).data(0).message("OK");
    public static final Wrapper SUCCESS = SUCCESS_BUILDER.build();

    // 通用错误 Builder
    public static final WrapperBuilder ERROR_BUILDER = Wrapper.builder().code(-1);
    public static final Wrapper ERROR = ERROR_BUILDER.message("ERROR").build();

    // 会话错误 Builder
    public static final WrapperBuilder SESSION_ERROR_BUILDER = Wrapper.builder().code(510);


}

```



**Builder构建者模式的使用**

拿上面的Wrapper举例，里面的`WrapperBuilder SUCCESS_BUILDER = Wrapper.builder().code(0).data(0).message("OK");`相当于构建了一个WrapperBuilder对象；只有当`Wrapper SUCCESS = SUCCESS_BUILDER.build();`使用了builde（）方法，才算是对象构建完成。可以理解为new Wrapper（），然后set属性



**怎么抛出异常，然后被全局异常捕获**

此处是在service层抛出异常，然后被全局异常处理器捕获

在可能出现异常的地方进行try-catch，catch的异常就是自定义的数据库异常，捕获异常后可以进行对应的异常抛出和处理；当抛出DatabaseSetDataException后会被全局异常处理器捕获到，最后返回对应的错误码

```java
@Service
public class YyAppointmentInfoServiceImpl extends ServiceImpl<YyAppointmentInfoMapper, YyAppointmentInfo> implements IYyAppointmentInfoService {
    @Autowired
    YyAppointmentInfoMapper yyAppointmentInfoMapper;
    @Autowired
    DataExceptionHandImpl dataExceptionHand;

    @Override
    public void setAppointInfo(YyAppointmentInfo appointmentInfo) {
        try {
            appointmentInfo.setRksj(LocalDateTime.now());
            yyAppointmentInfoMapper.insert(appointmentInfo);
        } catch (DataAccessException e) {
            //将存入数据异常的对象存入，传入对应的type，异常信息
            dataExceptionHand.handleInsertException(appointmentInfo,0,e);
        }
    }
}
```

