---
title: TCP的三次握手和四次挥手
date: 2025-06-29 14:08:59
tags:
categories: 计算机网络知识
---

[4.1 TCP 三次握手与四次挥手面试题 | 小林coding](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-三次握手过程是怎样的)学习笔记

# TCP报文格式

![img](https://img2018.cnblogs.com/blog/1290987/201906/1290987-20190615111551823-1173939851.png)

TCP报文 = TCP头部+TCP数据格式

TCP头部包含：

- 源端口
- 目标端口
- 序列号（保证TCP报文接收数据顺序和传递顺序是一致的，用来解决数据包乱序问题）
- 确认号（用来作为下一次期望收到的序列号，确保这个序号以前的数据包都被正常接收到，解决数据丢包问题）
- 等等

标志位：

- SYN：请求建立连接
- ACK：确认接收到报文，为1时才认为该确认号有效，为0时表示没有确认信息
- FIN：请求断开连接
- RST：由于主机发生宕机等错误原因，该标志位用来重置连接



# TCP三次握手

![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

TCP三次握手是为了HTTP请求时建立TCP连接

首先客户端和服务端都处于close状态（close表示没有建立连接，established表示处于连接状态），服务端首先会监听一个端口，处理listen状态

## 第一次握手

客户端会生成一个随机序号，并将该序号放入TCP报文的序列号字段中，对SYN标志位设置为1，这样即表示SYN报文。客户端将其SYN报文发送给服务端，之后客户端处于SYN_SENT状态，这个为TCP第一次握手

## 第二次握手

服务端收到客户端的SYN报文后，会将里面的客户端序号+1作为TCP报文的确认号字段，然后也会随机生成一个序号作为TCP报文的序列号字段，并且将SYN和ACK标志位设置为1。服务端会将SYN-ACK报文发送给客户端，之后服务端处于SYN_received状态。ACK是作为对客户端第一次握手的应答，SYN作为服务端第二次握手的发送请求建立连接信息。这是TCP第二次握手

## 第三次握手

客户端接收到服务端的SYN-ACK报文后，先会检验该报文的确认号是否合法，然后将该报文中的服务端序号+1作为TCP报文的确认号，并且设置ACK字段为1，表示该报文为ACK报文。最后将该报文发送给服务端，之后客户端处于established状态

服务端收到ACK报文也处于established状态，这是第三次握手



# TCP三次握手过程中丢包怎么办？

## 第一次握手丢包

如果在第一次握手丢包，说明客户端的SYN报文没有发送给服务端。那么客户端会收不到服务端的SYN-ACK报文应答，则会超时重传SYN报文再次请求建立连接。如果达到最大重传次数，客户端会断开连接

超时重传的时间由操作系统而定，一般为1s；当超时后会进行重传，并且每次超时时间为上一次的2倍，例如1s，2s，4s，8s重传

## 第二次握手丢包

第二次握手丢包，说明服务端的SYN-ACK报文没有发送给客户端。客户端的第一次握手收不到SYN-ACK应答，同时服务端也收不到客户端第二次握手的ACK报文。那么结果就是客户端的第一次握手会超时重传SYN报文给服务端，同时服务端的第二次握手也会超时重传SYN-ACK报文给客户端

## 第三次握手丢包

第三次握手丢包，说明客户端的ACK报文没有发送给服务端。服务端收不到ACK，报文则会在第二次握手的时候超时重传SYN-ACK报文给客户端



# TCP的四次挥手

![客户端主动关闭连接 —— TCP 四次挥手](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

TCP的四次挥手是为了断开TCP连接，客户端和服务端都可以作为主动关闭连接的一方

TCP断开连接需要从established状态变为close状态

## 第一次挥手

以客户端作为主动关闭连接一方为例，客户端会先发送FIN报文给服务端，之后客户端处于FIN_WAIT_1状态，表示客户端要关闭连接了

## 第二次挥手

服务端接收到客户端的FIN报文后，会回复一个ACK报文给客户端，并且处于close_wait状态，表示服务端可能还有数据未发送完

客户端收到该ACK报文后会处于FIN_wait_2状态，表示客户端等待服务端发送完数据

## 第三次挥手

服务端发送完数据，可以关闭连接时会发送FIN报文给客户端，之后处于last_ack状态，表示可以关闭连接等待最后回复

## 第四次挥手

客户端收到服务端的FIN报文后，会立马发送ACK应答报文（发送完ACK后会开始time_wait计时）给服务端，然后客户端开始进入time_wait（2MSL时间）状态中等待关闭连接。服务端收到ACK报文后会立马关闭连接

## 为什么time_wait状态需要2MSL？

MSL：报文的最大存活时间

以下拿客户端作为主动关闭连接方为例

- 防止本次连接的历史报文影响新连接：将time_wait设置为2MSL是为了保证客户端（第四次握手的ACK）的服务端（第三次握手超时重传的FIN）两端的报文都消失后才断开连接，然后建立新连接

- 保证被动关闭连接方可以正常关闭：当客户端的第四次握手发送ACK报文给服务端，在这个过程中可能存在ACK丢包，则服务端会在第三次握手超时重传FIN报文，并且FIN报文会在第二个MSL内到达客户端。所以ACK报文丢包和超时重传FIN报文，这么一来一回需要2MSL

## time_wait过多有什么危害？

- 服务端time_wait过多会导致浪费服务端资源，cpu资源，线程资源等
- 客户端time_wait过多会导致占满客户端端口，无法对同一个服务端再发起HTTP请求

客户端的time_wait过多：

- TCP连接是通过TCP四元组来唯一区分的，四元组：源ip，源端口，目标ip，目标端口
- 当客户端对同一个服务端（源ip+源端口相同）具有大量time_wait状态时，会占满该客户端的端口资源（客户端端口资源是有限的），TCP连接的四元组不能相同。则客户端无法再对这个服务端建立TCP连接，但是该客户端端口可以对其他服务端建立连接，因为其他服务端的源ip+源端口是不同的

服务端的time_wait过多：

- 服务端只是监听端口，可以容纳许多客户端端口的请求，但是time_wait过多会浪费资源
