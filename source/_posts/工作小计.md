---
title: 工作小计
date: 2025-04-16 10:15:03
tags:
---

### 日志输出
日志输出时都使用log.info等，不使用sys.out.println

---



## 业务积累

### 经纬度定位

业务中的地图某个点位置是根据经纬度来定位的。但是不同单位使用的地图不一样，可能是百度地图、高德地图等等，但是我们系统中使用的地图只能是一种，所以放入到我们系统中需要进行一个个地图的适配是比较繁琐的，我们统一在后端将不同的地图类型转换为同一个地图类型，然后输出给前端进行响应返回



### 加密算法

当需要对一张表里的某些字段进行加解密时

先在controller层创建一个加解密接口，参数为：1.表名tabName，2.加解密参数operation(0为需要加密，1为需要解密)

 

**加密流程： **

然后将该operation参数往下传递，如果operation为0，此时有一张加解密关联表（该表记录了需要加解密的字段），通过遍历该关联表，获取到需要加密的字段，通过SM2算法来进行对字段进行加密（使用SM2算法时，需要先连接密码机，创建连接，生成SM2公钥，进行加密，关闭连接），加密后返回该加密的字段，更新表中原来的字段

 

**解密流程：**

和加密流程相似

当operation字段为1，获取关联表中需要加密的字段进行解密（创建连接，连接到密码机后，生成SM2私钥，通过该私钥对字段进行解密，最后关闭连接），返回解密后的数据更新表

---

## 技术积累

### 全局异常捕获和状态码返回

**怎么定义全局异常？** 

想要使用全局异常首先需要定义一个`GlobalExceptionHandler.java`类和自定义异常类`DatabaseSetDataException` 

```Java
@Getter
@Setter
public class DatabaseSetDataException extends RuntimeException {

    private Integer code = 50001;
    private String message;

    public DatabaseSetDataException(String message){
        this.message = message;
    }

}
```

```Java
@Slf4j
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {
    // 数据库异常
    @ExceptionHandler(DatabaseException.class)
    public Wrapper handleDataAccessException(DatabaseSetDataException ex) {
        log.error("数据库操作失败: "+ex.getMessage());
        return Wrapper.ERROR_BUILDER //在这里调用wrapper的Eror_builder会将Wrapper里原先设置的code(-1)进行覆盖，不会产生两个code
                .code(ex.getCode())
                .message("操作失败")
                .build();
    }

}
```



**Wrapper是什么？**

Wrapper是状态码的统一返回规范类

```Java
@Data
@Builder//启用builder构建者模式
@NoArgsConstructor
@AllArgsConstructor
public class Wrapper implements ResponseRestful {

    private int code;

    private String message;

    @Getter
    private Object data;

    // 成功响应 Builder
    //如果使用SUCCESS的话，会先调用suc_builder进行拼接code和message
    public static final WrapperBuilder SUCCESS_BUILDER = Wrapper.builder().code(0).data(0).message("OK");
    public static final Wrapper SUCCESS = SUCCESS_BUILDER.build();

    // 通用错误 Builder
    public static final WrapperBuilder ERROR_BUILDER = Wrapper.builder().code(-1);
    public static final Wrapper ERROR = ERROR_BUILDER.message("ERROR").build();

    // 会话错误 Builder
    public static final WrapperBuilder SESSION_ERROR_BUILDER = Wrapper.builder().code(510);


}

```



**Builder构建者模式的使用**

拿上面的Wrapper举例，里面的`WrapperBuilder SUCCESS_BUILDER = Wrapper.builder().code(0).data(0).message("OK");`相当于构建了一个WrapperBuilder对象；只有当`Wrapper SUCCESS = SUCCESS_BUILDER.build();`使用了builde（）方法，才算是对象构建完成。可以理解为new Wrapper（），然后set属性



**怎么抛出异常，然后被全局异常捕获**

此处是在service层抛出异常，然后被全局异常处理器捕获

在可能出现异常的地方进行try-catch，catch的异常就是自定义的数据库异常，捕获异常后可以进行对应的异常抛出和处理；当抛出DatabaseSetDataException后会被全局异常处理器捕获到，最后返回对应的错误码

```java
@Service
public class YyAppointmentInfoServiceImpl extends ServiceImpl<YyAppointmentInfoMapper, YyAppointmentInfo> implements IYyAppointmentInfoService {
    @Autowired
    YyAppointmentInfoMapper yyAppointmentInfoMapper;
    @Autowired
    DataExceptionHandImpl dataExceptionHand;

    @Override
    public void setAppointInfo(YyAppointmentInfo appointmentInfo) {
        try {
            appointmentInfo.setRksj(LocalDateTime.now());
            yyAppointmentInfoMapper.insert(appointmentInfo);
        } catch (DataAccessException e) {
            //将存入数据异常的对象存入，传入对应的type，异常信息
            dataExceptionHand.handleInsertException(appointmentInfo,0,e);
        }
    }
}
```

