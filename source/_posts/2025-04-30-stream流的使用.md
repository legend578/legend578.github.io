---
title: stream流的入门和使用
date: 2025-04-27 21:43:58
categories: # 分类
	- 技术点  # 只能由一个
tags: # 标签
	- stream流 
---

# stream流的概念

stream流可以看做一条流水线，先将数据读入stream流，在stream流上可以对数据进行一系列处理

# stream流的使用

stream流可以对单列集合，双列集合，数组，零散数据进行一系列处理，过滤，收集，最后得到想要的结果

## 单列集合使用stream流（list、set）

单列集合通过Collections中的方法获取stream流

使用stream流的forEach方法来遍历list集合，并且顺序打印他

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        List<String>list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        list.add("e");
        /*
        //获取一条流水线,将该list集合的数据放到stream流水线上（stream流的匿名内部类的用法）
        Stream<String> stream = list.stream();
        stream.forEach(new Consumer<String>() {//使用forEach来遍历list集合
            @Override
            public void accept(String s){//这里的s表示list集合中的一条数据
                System.out.println(s);
            }
        });*/

        //可以使用stream的链式调用（lambda）简化操作，这里的s代表list集合中的一条数据
        //s代表上面的匿名内部类的形参，->后面的操作是该形参的操作方法
        list.stream().forEach(s -> System.out.println(s));
    }
}
```



## 双列集合使用stream流（map）

双列集合不能直接使用stream流，需要map先获取到key或entryKey后，才可以获取到stream流

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        HashMap<String,Integer> map = new HashMap<>();
        map.put("aaa",111);
        map.put("bbb",222);
        map.put("ccc",33);
        map.put("ddd",44);

        //map不能直接获取stream流，需要进行中转
        //1.map可以先通过获取键集合后，之后使用stream流
        map.keySet().stream().forEach(s -> System.out.println(s));

        System.out.println("=============");
        
        //2.map也可以通过键值对集合后，使用stream流
        map.entrySet().stream().forEach(s-> System.out.println(s));
    }
}
```

```
aaa
ccc
bbb
ddd
=============
aaa=111
ccc=33
bbb=222
ddd=44
```



## 数组使用stream流

数组可以通过Arrays直接使用stream流，将数组名传入即可

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        int[]arr = {1,2,3,4,5};

        String[]str = {"a","b","c"};
        //数组使用stream流可以直接通过Arrays方法，将数组名传入即可
        Arrays.stream(arr).forEach(s-> System.out.println(s));

        System.out.println("=========");

        Arrays.stream(str).forEach(s -> System.out.println(s));
    }
}
```



## 零散的数据使用stream流

零散的数据可以直接通过stream的of方法，进行使用stream流

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        Stream.of(1,2,3,4,5).forEach(s-> System.out.println(s));
        Stream.of("ab","cd","ef").forEach(s-> System.out.println(s));
    }
}
```



# stream流的中间方法

**stream流的中间方法使用后会生成一个新的stream流，原stream流调用中间方法后就会关闭，不能使用了**

**中间方法只会修改stream流，传入stream流的原始数据不会变化**

****

```
Stream<T> filter(Predicate<? super T> predicate)----》过滤
Stream<T> limit(long maxSize)----》获取前几个元素
Stream<T> skip(long n)----》跳过前几个元素
Stream<T> distinct()----》元素去重，依赖(hashCode和equals方法)
static <T> Stream<T> concat(Stream a, Stream b)----》合并a和b两个流为一个流
Stream<R> map(Function<T ,R> mapper)----》转换流中的数据类型
```

## filter方法

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        ArrayList<String> list = new ArrayList<>();
        Collections.addAll(list,"张无忌","周芷若","赵敏","张强","张三丰","张翠山","张良","王二麻子","谢广坤");
        /*
        //先使用stream流的匿名内部类的方式
        Stream<String> stream = list.stream();
        stream.filter(new Predicate<String>() {
            @Override
            public boolean test(String s) {
                //如果为true则该条数据留下，如果startsWith判断该条记录是'张'开头的数据则返回true
                //如果为false则该条数据丢弃
                if(s.startsWith("张"))return true;
                else return false;
            }
        }).forEach(s-> System.out.println(s));
        */

        // 使用stream流的lambda表达式进行链式调用
        // s代表遍历过程中的一条记录，filter会判断当前记录是否是张开头，如果是则保留
        list.stream().filter(s->s.startsWith("张")).forEach(s-> System.out.println(s));
    }
}
```

```
张无忌
张强
张三丰
张翠山
张良
```



## skip和limit方法

skip：跳过集合的前几个元素

limit：获取集合的前几个元素

这两个方法都是基于前一个中间方法操作后的新stream流的数据进行的

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        ArrayList<String> list = new ArrayList<>();
        Collections.addAll(list,"张无忌","周芷若","赵敏","张强","张三丰","张翠山","张良","王二麻子","谢广坤");

        //skip表示跳过该集合的前3条记录，limit表示只显示该集合的4-7条记录
        list.stream()
                .skip(3)
                .limit(4)
                .forEach(s-> System.out.println(s));
    }
}
```

```
张强
张三丰
张翠山
张良
```



## distinct和concat方法

distinct：给集合中的元素去重，如果是list中存放的是自定义类，需要重写HashCode和equals方法才会生效

concat：Stream流的静态方法，用来合并stream流里的数据

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        ArrayList<String> list1 = new ArrayList<>();
        Collections.addAll(list1,"张无忌","张无忌","张无忌","周芷若","谢广坤");

        ArrayList<String> list2 = new ArrayList<>();
        Collections.addAll(list2,"sky","okk");

        //distinct表示给集合去重，如果是list中存放的是自定义类，需要重写HashCode和equals方法才会生效
        list1.stream()
                .distinct()
                .forEach(s-> System.out.println(s));

        System.out.println("==============");

        //合并两个stream流
        Stream.concat(list1.stream(),list2.stream()).forEach(s-> System.out.println(s));
    }
}
```

```
张无忌
周芷若
谢广坤
==============
张无忌
张无忌
张无忌
周芷若
谢广坤
sky
okk
```



## map方法

map方法用来给集合中的元素一系列处理（类型转换，修改数据）

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        ArrayList<String> list = new ArrayList<>();
        Collections.addAll(list,"张无忌-15","周芷若-14","赵敏-13","张强-20","张三丰-100","张翠山-40");

        //当想要对list中的数据进行类型转换时，使用stream流中的map方法（匿名内部类形式）
        list.stream().map(new Function<String, Integer>() {//需要获取String字符串中的数字
            @Override
            public Integer apply(String s) {
                //s表示遍历集合过程中的一条记录
                //先进行分割字符串，再提取数字，最后类型转换返回age
                String[] strings = s.split("-");
                String str = strings[1];
                int age = Integer.parseInt(str);
                return age;
            }
        }).forEach(s-> System.out.println(s));

        System.out.println("==============");

        //使用map方法的lambda形式
        list.stream()
                .map(s->Integer.parseInt(s.split("-")[1]))
                .forEach(s-> System.out.println(s));
    }
}
```



# Stream的终结方法

**终结方法：当stream流执行完终结方法后就会退出stream流，然后返回**

```
void forEach(Consumer action)---->遍历
long count()---->统计
toArray()---->收集流中的数据，放到数组中
collect(Collector collector)---->收集流中的数据，放到集合中
```

## forEach和count方法

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        ArrayList<String> list = new ArrayList<>();
        Collections.addAll(list,"张无忌-15","周芷若-14","赵敏-13");

        //forEach用来遍历集合
        list.stream().forEach(s-> System.out.println(s));

        //count用来统计集合个数
        long count = list.stream().count();
        System.out.println(count);

    }
}
```



## toArray方法

stream流的toArray方法会先创建一个数组，然后stream流将list中的数据一个个赋值到该数组中，最后返回该数组

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        ArrayList<String> list = new ArrayList<>();
        Collections.addAll(list,"张无忌-15","周芷若-14","赵敏-13");

        //toArray方法用来将集合变为数组
        //1.将集合转换为默认Object类型的数组
        Object[] arr1 = list.stream().toArray();
        System.out.println(Arrays.toString(arr1));

        //2.1使用匿名内部类的方式，将集合转换为指定类型的数组
        Stream<String> stream = list.stream();
        String[] arr2 = stream.toArray(new IntFunction<String[]>() {
            @Override
            public String[] apply(int value) {//value表示数组长度
                return new String[value];//这里面填写数组长度
            }
        });
        System.out.println(Arrays.toString(arr2));

        //2.2使用lambda表达式，将集合转换为指定类型的数组
        //lambda表达式省略return，会将new String[value]该值直接返回
        String[] arr3 = list.stream().toArray(value -> new String[value]);
        System.out.println(Arrays.toString(arr3));

    }
}
```

```Java
[张无忌-15, 周芷若-14, 赵敏-13]
[张无忌-15, 周芷若-14, 赵敏-13]
[张无忌-15, 周芷若-14, 赵敏-13]
```



## collect方法(将数据转换为List,Set,Map集合)

stream流的collect方法可以将数据进行一系列处理后，转换为不同的集合

**将数据收集到list和set中**

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        ArrayList<String> list = new ArrayList<>();
        Collections.addAll(list,"张无忌-男-15","张无忌-男-15","周芷若-女-14","赵敏-女-13");

        //收集所有为男性的信息到list中
        List<String> list1 = list.stream()
                .filter(s -> "男".equals(s.split("-")[1]))
                .collect(Collectors.toList());
        System.out.println(list1);

        //收集所有为男性的信息到set中,收集到set中时会自动去重
        Set<String> set = list.stream()
                .filter(s -> "男".equals(s.split("-")[1]))
                .collect(Collectors.toSet());
        System.out.println(set);
    }
}
```

```Java
[张无忌-男-15, 张无忌-男-15]
[张无忌-男-15]
```



**将数据收集到map中**

```Java
@SpringBootTest
@Slf4j
class WorkTestApplicationTests {
    @Test
    public void testStream() {
        ArrayList<String> list = new ArrayList<>();
        Collections.addAll(list,"张无忌-男-15","sky-男-16","周芷若-女-14","赵敏-女-13");

        //1.使用匿名内部类，收集数据到map中
        //将数据收集到map中，需要定义键值对的规则，如果存入map中的key重复时会抛出异常(例如当有两个张无忌存在时，java.lang.IllegalStateException: Duplicate key 15)
        //此处将list中的姓名作为key，年龄作为value
        Map<String, Integer> map1 = list.stream()
                .filter(s -> "男".equals(s.split("-")[1]))
                .collect(Collectors.toMap(new Function<String, String>() {//第一部分是键的规则
                    //键的定义规则：在new Function<String, String>中第一个String指的是apply方法的形参（即集合中的数据）
                    // 第二个String表示apply方法的返回值，将该返回值作为map的key
                    @Override
                    public String apply(String s) {
                        return s.split("-")[0];
                    }
                }, new Function<String, Integer>() {//第二部分是值的规则
                    //值的定义规则和键的相同，new Function<String, Integer>中第一个参数String为形参（list中的数据）
                    //第二个参数Integer则表示apply方法的返回值，将该返回值作为map的value
                    @Override
                    public Integer apply(String s) {
                        return Integer.parseInt(s.split("-")[2]);
                    }
                }));
        System.out.println(map1);

        System.out.println("===========");

        //2.使用lambda表达式，将数据收集到map中
        Map<String, Integer> map2 = list.stream()
                .filter(s -> "男".equals(s.split("-")[1]))
                .collect(Collectors.toMap(s1->s1.split("-")[0],s2->Integer.parseInt(s2.split("-")[2])));
        System.out.println(map2);

    }
}
```

```Java
{sky=16, 张无忌=15}
===========
{sky=16, 张无忌=15}
```

